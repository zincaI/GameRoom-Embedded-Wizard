$version 13.04

// This is the root component of the entire GUI application.
$rect <1766,990,1966,1030>
$output false
class Application : Core::Root
{
  $rect <-600,295,-400,335>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Application::BackgroudGamingRoom;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton WordGuessingButton
  {
    preset Bounds = <155,172,287,305>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressGuessingWordGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::WordGuessingLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <-610,405,-370,445>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <-290,65,-60,105>
  slot OpenGuessingWordGame
  {
    //if ( IsDialog(false))
     //Owner.DismissDialog( this, null, null, null, null, null, false );
    //                     trace "Actual dialog1g", Owner;
    if ( IsActiveDialog( true ))
    {

      //GetRoot().PresentDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
      GetRoot().SwitchToDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //      trace "Actual dialog2g", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;

  }

  // Starting games
  note group StartingGames
  {
    attr Bounds = <-330,15,-30,225>;
  }

  // Effects handling
  note group Effects
  {
    attr Bounds = <-330,255,-30,455>;
  }

  // Timers for the effects
  note group Timers
  {
    attr Bounds = <-650,15,-350,215>;
  }

  $rect <-600,55,-400,95>
  object Core::Timer TimerGuessingGame
  {
    preset OnTrigger = OpenGuessingWordGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-300,305,-50,345>
  slot OnPressGuessingWordGame
  {
    WordGuessingButton.Icon=Application::OnPressWordGuessingLogo;


    TimerGuessingGame.Enabled=true;


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MemoryGameButton
  {
    preset Bounds = <322,169,454,302>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressMemoryGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::MemoryGameLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <-290,115,-60,155>
  slot OpenMemoryGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //  trace "Actual dialog1m", Owner;

    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //                       trace "Actual dialog2m", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,355,-50,395>
  slot OnPressMemoryGame
  {
    MemoryGameButton.Icon=Application::OnPressMemoryGameLogo;


    TimerMemoryGame.Enabled=true;


  }

  $rect <-600,105,-400,145>
  object Core::Timer TimerMemoryGame
  {
    preset OnTrigger = OpenMemoryGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-600,235,-400,275>
  slot DisableButtons
  {
    WordGuessingButton.Enabled=false;
    WordGuessingButton.Visible=false;
    MemoryGameButton.Enabled=false;
    MemoryGameButton.Visible=false;
    TilesPuzzleGameButton.Enabled=false;
    TilesPuzzleGameButton.Visible=false;
    Arrow.Enabled=false;
    Arrow.Visible=false;
    Sound.Enabled=false;
    Sound.Visible=false;

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TilesPuzzleGameButton
  {
    preset Bounds = <484,169,631,302>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressTilesPuzzleGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::TilesPuzzleLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <-600,155,-400,195>
  object Core::Timer TimeTilesPuzzleGame
  {
    preset OnTrigger = OpenTilesPuzzleGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-290,165,-60,205>
  slot OpenTilesPuzzleGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //      trace "Actual dialog1t", Owner;
    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null,null, false );
    //  trace "Actual dialog2t", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,405,-50,445>
  slot OnPressTilesPuzzleGame
  {
    TilesPuzzleGameButton.Icon=Application::OnPressTilesPuzzleLogo;


    TimeTilesPuzzleGame.Enabled=true;


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Arrow
  {
    preset Bounds = <818,340,912,391>;
    preset Icon = Application::Arrow;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <-580,360,-400,395>
  inherited method Init()
  {
    if(MusicPlay==true)
    {
    $if (!$prototyper)
    native{playMusic();}
    $endif
    MusicPlay=false;
    }
    //if ( IsActiveDialog( true ))
    //{
    //
    //  //GetRoot().PresentDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
    //  //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
    //  GetRoot().SwitchToDialog( new Application::GameRoom,null,null, null, null, null, null, null, null, null, false );
    ////      trace "Actual dialog2g", Owner;
    //}



  }

  $rect <-590,460,-390,500>
  var bool MusicPlay = true;

  $rect <-280,480,-80,520>
  slot MusicSLot
  {
    //if(Application::GuessTheWordMenu.MusicState==true)
    //{
    //$if (!$prototyper)
    //native{pauseMusic();}
    //$endif
    //Application::GuessTheWordMenu.MusicState=false; 
    //}
    //else
    //{
    //$if (!$prototyper)
    //native{playMusic();}
    //$endif 
    //Application::GuessTheWordMenu.MusicState=true;
    //}
    var bool musicPlaying=true;
     $if (!$prototyper)
    native{isAudioPlaying(musicPlaying);}
    $endif

    if(musicPlaying==true)
    {
    $if (!$prototyper)
    native{pauseMusic();}
    $endif
    musicPlaying=false; 
    }
    else
    {
    $if (!$prototyper)
    native{playMusic();}
    $endif 
    musicPlaying=true;
    }
    // $endif 




  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Sound
  {
    preset Bounds = <33,42,102,94>;
    preset OnPress = MusicSLot;
    preset Icon = Application::sound_off;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member Image
  $member WordGuessingButton
  $member TransparentButton
  $member OpenGuessingWordGame
  $member StartingGames
  $member Effects
  $member Timers
  $member TimerGuessingGame
  $member OnPressGuessingWordGame
  $member MemoryGameButton
  $member OpenMemoryGame
  $member OnPressMemoryGame
  $member TimerMemoryGame
  $member DisableButtons
  $member TilesPuzzleGameButton
  $member TimeTilesPuzzleGame
  $member OpenTilesPuzzleGame
  $member OnPressTilesPuzzleGame
  $member Arrow
  $member MusicPlay
  $member MusicSLot
  $member Sound
}

$rect <1420,980,1660,1020>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 38;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <740,780,980,820>
$output false
resource Resources::Bitmap BackgroudGamingRoom
{
  attr bitmapfile FileName = .\background_entry_room.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Images
note group Note
{
  attr Bounds = <690,-20,2220,910>;
}

$rect <740,460,980,500>
$output false
resource Resources::Bitmap WordGuessingLogo
{
  attr bitmapfile FileName = .\button_guess_words_game2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Classes
note group Note1
{
  attr Bounds = <1730,940,2220,1180>;
}

$rect <1766,1040,1966,1080>
$output false
class GuessTheWord : Core::Group
{
  $rect <-510,650,-310,690>
  inherited property Bounds = <0,0,800,496>;

  $rect <-120,680,80,720>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-120,640,80,680>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <177,42,263,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <293,42,379,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <413,42,499,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Bounds = <534,42,620,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Text FirstLetter
  {
    preset Bounds = <185,49,257,112>;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object Views::Text SecondLetter
  {
    preset Bounds = <300,49,372,112>;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object Views::Text ThirdLetter
  {
    preset Bounds = <420,49,492,112>;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object Views::Text ForthLetter
  {
    preset Bounds = <541,49,613,112>;
    preset OnUpdate = null;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton q
  {
    preset Bounds = <84,189,131,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::q;
    preset Label = "Q";
    preset Appearance = TransparentButton;
  }

  $rect <-1031,213,-791,253>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <20,20,160,60>
  object WidgetSet::PushButton m
  {
    preset Bounds = <521,327,569,382>;
    preset OnPress = PressLetter;
    preset Icon = Application::m;
    preset Label = "M";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton w
  {
    preset Bounds = <147,190,202,245>;
    preset OnPress = PressLetter;
    preset Icon = Application::w;
    preset Label = "W";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton e
  {
    preset Bounds = <212,190,265,248>;
    preset OnPress = PressLetter;
    preset Icon = Application::e;
    preset Label = "E";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton r
  {
    preset Bounds = <280,187,328,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::r;
    preset Label = "R";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton t
  {
    preset Bounds = <341,187,389,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::t;
    preset Label = "T";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton y
  {
    preset Bounds = <396,187,444,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::y;
    preset Label = "Y";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton u
  {
    preset Bounds = <461,188,509,243>;
    preset OnPress = PressLetter;
    preset Icon = Application::u;
    preset Label = "U";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton i
  {
    preset Bounds = <527,187,575,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::i;
    preset Label = "I";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton o
  {
    preset Bounds = <594,187,642,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::o;
    preset Label = "O";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton p
  {
    preset Bounds = <660,187,708,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::p;
    preset Label = "P";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton A
  {
    preset Bounds = <98,243,146,325>;
    preset OnPress = PressLetter;
    preset Icon = Application::a;
    preset Label = "A";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton s
  {
    preset Bounds = <146,258,194,319>;
    preset OnPress = PressLetter;
    preset Icon = Application::s;
    preset Label = "S";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton d
  {
    preset Bounds = <212,260,260,315>;
    preset OnPress = PressLetter;
    preset Icon = Application::d;
    preset Label = "D";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton f
  {
    preset Bounds = <280,257,328,312>;
    preset OnPress = PressLetter;
    preset Icon = Application::f;
    preset Label = "F";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton g
  {
    preset Bounds = <341,254,389,312>;
    preset OnPress = PressLetter;
    preset Icon = Application::g;
    preset Label = "G";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton h
  {
    preset Bounds = <396,256,444,311>;
    preset OnPress = PressLetter;
    preset Icon = Application::h;
    preset Label = "H";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton j
  {
    preset Bounds = <461,261,509,316>;
    preset OnPress = PressLetter;
    preset Icon = Application::j;
    preset Label = "J";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton k
  {
    preset Bounds = <523,257,571,312>;
    preset OnPress = PressLetter;
    preset Icon = Application::k;
    preset Label = "K";
    preset Appearance = TransparentButton;
  }

  $rect <-670,590,-490,630>
  inherited method Init()
  {
    var int32 wordChoice=0;
    RandomChoice.String=string(wordChoice);

    //FirstLetter.String="";
    //SecondLetter.String="";
    //ThirdLetter.String="";
    //ForthLetter.String="";
    //LettersToUse.Visible=false;
    //GuessedLetters.String="";
    //GuessedLetters.Visible=false;
    //wordChoice = math_rand(0, 3);

  }

  // The disclaimer with the guessed letters that were not yet placed in the correct \
  // spot.
  $rect <20,20,160,60>
  object Views::Text GuessedLettersNote
  {
    preset Bounds = <-55,399,670,486>;
    preset ColorTR = #FFCC2DFF;
    preset ColorTL = #FFDEB9FF;
    preset String = "Don't forget to use these letters:";
    preset Font = Application::WordGuessingGameFont;
    preset Visible = false;
  }

  // Game logic
  note group NoteGameLogic
  {
    attr Bounds = <-760,140,-150,640>;
  }

  $rect <20,20,160,60>
  object Views::Text GuessedText
  {
    preset StackingPriority = 2;
    preset Bounds = <217,166,549,343>;
    preset Padding = 0;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You won!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Visible = false;
  }

  $rect <-400,230,-200,270>
  slot GuessWord
  {
    var string firstOption="0";
    if(ForthLetter.String=="")
    {
        var slot sl = this.UnfilledSpacesSlot;
        signal sl;
    }          
    else
    {
    if(RandomChoice.String==firstOption)
    {
        var slot sl = this.GuessWordGame;
        signal sl;
        if(FirstLetter.Color!=#111111ff)
        FirstLetter.String="";
        
            if(SecondLetter.Color!=#111111ff)
        SecondLetter.String="";
        
            if(ThirdLetter.Color!=#111111ff)
        ThirdLetter.String="";

            if(ForthLetter.Color!=#111111ff)
        ForthLetter.String="";

    }
    //else if(wordChoice==1)
    //{
    //}
    //else if(wordChoice==2)
    //{
    //}
    //else if(wordChoice==3)
    //{
    //}
    }
  }

  $rect <20,20,160,60>
  object Views::Text RandomChoice
  {
    preset Bounds = <-287,654,-187,684>;
    preset String = "Text";
    preset Font = Resources::DefaultFont;
  }

  // Keyboard (for Enter see GuessWord)
  note group Keyboard
  {
    attr Bounds = <-700,180,-440,370>;
  }

  $rect <-400,280,-200,320>
  slot GuessWordGame
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

        if(FirstLetter.String=="G")
        {
           FirstLetter.Color=#111111ff;
           if(GuessedLetters.String!="")
           {
     
           var int32 poz=GuessedLetters.String.find( 'G', 0 );
           if(poz !=0)
             {
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
             if(GuessedLetters.String==" ")
             {
                GuessedLettersNote.Visible=false;
             }
           
           }
        }
        }
        else if(SecondLetter.String=="G" || ThirdLetter.String=="G" || ForthLetter.String=="G")
        {
                GuessedLettersNote.Visible=true;
                            if(GuessedLetters.String[0]!='G' && GuessedLetters.String[1]!='G' && GuessedLetters.String[2]!='G' && GuessedLetters.String[3]!='G')
                {
                GuessedLetters.String=GuessedLetters.String+" G";   
                }
                GuessedLetters.Visible=true;
        }

            if(SecondLetter.String=="A")
        {
           SecondLetter.Color=#111111ff;
            if(GuessedLetters.String!="")
           {
     
           var int32 poz=GuessedLetters.String.find( 'A', 0 );
           if(poz !=0)
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
           
           }
        }
            else if(FirstLetter.String=="A" || ThirdLetter.String=="A" || ForthLetter.String=="A")
        {
                GuessedLettersNote.Visible=true;
                if(GuessedLetters.String[0]!='A' && GuessedLetters.String[1]!='A' && GuessedLetters.String[2]!='A' && GuessedLetters.String[3]!='A')
                {
                GuessedLetters.String=GuessedLetters.String+" A";
                }
                GuessedLetters.Visible=true;
        }

            if(ThirdLetter.String=="M")
        {
           ThirdLetter.Color=#111111ff;
                  var int32 poz=GuessedLetters.String.find( 'M', 0 );
           if(poz !=0)
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
           
        }
        else if(SecondLetter.String=="M" || FirstLetter.String=="M" || ForthLetter.String=="M")
        {
                GuessedLettersNote.Visible=true;            
                if(GuessedLetters.String[0]!='M' && GuessedLetters.String[1]!='M' && GuessedLetters.String[2]!='M' && GuessedLetters.String[3]!='M')
                 {
                GuessedLetters.String=GuessedLetters.String+" M";   
                }
                GuessedLetters.Visible=true;
        }

            if(ForthLetter.String=="E")
        {
           ForthLetter.Color=#111111ff;
                  var int32 poz=GuessedLetters.String.find( 'E', 0 );
           if(poz !=0)
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
           
        }
            else if(SecondLetter.String=="E" || ThirdLetter.String=="E" || FirstLetter.String=="E")
        {
                GuessedLettersNote.Visible=true;
                if(GuessedLetters.String[0]!='E' && GuessedLetters.String[1]!='E' && GuessedLetters.String[2]!='E' && GuessedLetters.String[3]!='E')
                {
                GuessedLetters.String=GuessedLetters.String+" E";
                }
                GuessedLetters.Visible=true;
        }
        
        if(FirstLetter.String=="G" && SecondLetter.String=="A" && ThirdLetter.String=="M" && ForthLetter.String=="E")
    {
                 GuessedText.Visible=true;
                 //FilterKeyboard.Visible=true;
                 RevealFilterTimer.Enabled=true;
                 var slot sl=this.DisableKeyboard;
                 signal sl;
                 GuessedLettersNote.Visible=false;
    }

  }

  // Word choices
  note group WordChoices
  {
    attr Bounds = <-430,180,-180,370>;
  }

  $rect <20,20,160,60>
  object Views::Text GuessedLetters
  {
    preset Bounds = <535,425,635,455>;
    preset ColorTR = #FFCC2DFF;
    preset ColorTL = #FFDEB9FF;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton delete_key
  {
    preset Bounds = <585,257,735,307>;
    preset OnPress = PressDelete;
    preset Icon = Application::delete_key;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton enter
  {
    preset Bounds = <585,327,735,377>;
    preset OnPress = GuessWord;
    preset Icon = Application::enter;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton l
  {
    preset Bounds = <104,322,153,387>;
    preset OnPress = PressLetter;
    preset Icon = Application::l;
    preset Label = "L";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton z
  {
    preset Bounds = <153,329,201,379>;
    preset OnPress = PressLetter;
    preset Icon = Application::z;
    preset Label = "Z";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton x
  {
    preset Bounds = <217,327,265,377>;
    preset OnPress = PressLetter;
    preset Icon = Application::x;
    preset Label = "X";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton c
  {
    preset Bounds = <283,325,325,375>;
    preset OnPress = PressLetter;
    preset Icon = Application::c;
    preset Label = "C";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton v
  {
    preset Bounds = <341,327,381,377>;
    preset OnPress = PressLetter;
    preset Icon = Application::v;
    preset Label = "V";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton b
  {
    preset Bounds = <406,329,446,379>;
    preset OnPress = PressLetter;
    preset Icon = Application::b;
    preset Label = "B";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton n
  {
    preset Bounds = <461,332,510,382>;
    preset OnPress = PressLetter;
    preset Icon = Application::n;
    preset Label = "N";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object Views::Text UnfilledSpaces
  {
    preset Bounds = <23,36,783,126>;
    preset ColorTR = #FF7403FF;
    preset String = "Fill all the spaces";
    preset Font = Application::WordGuessingGameFont;
    preset Visible = false;
  }

  $rect <-690,530,-450,570>
  object Core::Timer TimerUnfilledSpaces
  {
    preset OnTrigger = DismissUnfilledSpacesWarning;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-690,480,-450,520>
  slot UnfilledSpacesSlot
  {
    UnfilledSpaces.Visible=true;
    UnfilledSpaces.Color=UnfilledSpacesGradient.Value;
    TimerUnfilledSpaces.Enabled=true;

  }

  $rect <-690,430,-450,470>
  slot DismissUnfilledSpacesWarning
  {
    UnfilledSpaces.Visible=false;

  }

  $rect <-670,310,-470,350>
  slot PressDelete
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(ForthLetter.String!="" && ForthLetter.Color!=#111111ff)
    {
    ForthLetter.String="";
    }
    else if(ThirdLetter.String!="" && ThirdLetter.Color!=#111111ff)
    {
    ThirdLetter.String="";
    }
    else if(SecondLetter.String!="" && SecondLetter.Color!=#111111ff)
    {
    SecondLetter.String="";
    }
    else if(FirstLetter.Color!=#111111ff) FirstLetter.String="";
  }

  $rect <-670,260,-470,300>
  slot PressLetter
  {
    sender; /* the method is called from the sender object */
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    var string toAddLetter;

    var WidgetSet::PushButton currentSender = (WidgetSet::PushButton )sender;

    if(currentSender==null)
    {
      if(LetterKeyHandler.CharCode>='A' && LetterKeyHandler.CharCode<='Z')
      {
        toAddLetter=string(LetterKeyHandler.CharCode);
      }
      else if (LetterKeyHandler.CharCode>='a' && LetterKeyHandler.CharCode<='z')
      {
          toAddLetter=string(LetterKeyHandler.CharCode-32);
      }
    }
    else
    {
       toAddLetter=currentSender.Label;
    }


    if(FirstLetter.String=="")
    {
    FirstLetter.String=toAddLetter;
    }
    else if(SecondLetter.String=="")
    {
    SecondLetter.String=toAddLetter;

    }
    else if(ThirdLetter.String=="")
    {
    ThirdLetter.String=toAddLetter;

    }
    else if(ForthLetter.String=="")
    {
    ForthLetter.String=toAddLetter;

    }


    FilterKeyboard.Visible=true;
    var slot sl = this.DisableKeyboard;
    signal sl;
    ButtonPressed.Enabled=true;



  }

  $rect <-1251,173,-1021,213>
  object Effects::ColorEffect UnfilledSpacesGradient
  {
    preset CycleDuration = 2000;
    preset Enabled = true;
  }

  // Special effects
  note group SpecialEffects
  {
    attr Bounds = <-1270,140,-770,710>;
  }

  $rect <-400,440,-200,480>
  object Core::Timer ButtonPressed
  {
    preset OnTrigger = PressButtonEffect;
    preset Period = 0;
    preset Begin = 300;
  }

  // Handling unfilled spaces
  note group HandlingUnfilledSpaces
  {
    attr Bounds = <-700,380,-440,580>;
  }

  // Handling unfilled spaces(also see keyboard above)
  note group HandlingButtonPressed
  {
    attr Bounds = <-430,380,-170,580>;
  }

  $rect <-400,490,-200,530>
  slot PressButtonEffect
  {
    FilterKeyboard.Visible=false;
    var slot sl = this.EnableKeyboard;
    signal sl;
  }

  $rect <20,20,160,60>
  object Views::FilterImage FilterKeyboard
  {
    preset Bounds = <74,180,735,393>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = Application::SandColor;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 180;
    preset Visible = false;
  }

  $rect <-1241,273,-1041,313>
  slot DisableKeyboard
  {
     k.Enabled=false;
                 A.Enabled=false;
                 b.Enabled=false;
                 c.Enabled=false;
                 e.Enabled=false;
                 f.Enabled=false;
                 g.Enabled=false;
                 h.Enabled=false;
                 i.Enabled=false;
                 j.Enabled=false;
                 l.Enabled=false;
                 m.Enabled=false;
                 n.Enabled=false;
                 o.Enabled=false;
                 p.Enabled=false;
                 q.Enabled=false;
                 r.Enabled=false;
                 d.Enabled=false;
                 t.Enabled=false;
                 w.Enabled=false;
                 x.Enabled=false;
                 y.Enabled=false;
                 z.Enabled=false;
                 s.Enabled=false;
                 u.Enabled=false;
                 v.Enabled=false;
                 enter.Enabled=false;
                 delete_key.Enabled=false;
  }

  $rect <-1241,223,-1041,263>
  slot EnableKeyboard
  {
     k.Enabled=true;
                 A.Enabled=true;
                 b.Enabled=true;
                 c.Enabled=true;
                 e.Enabled=true;
                 f.Enabled=true;
                 g.Enabled=true;
                 h.Enabled=true;
                 i.Enabled=true;
                 j.Enabled=true;
                 l.Enabled=true;
                 m.Enabled=true;
                 n.Enabled=true;
                 o.Enabled=true;
                 p.Enabled=true;
                 q.Enabled=true;
                 r.Enabled=true;
                 d.Enabled=true;
                 t.Enabled=true;
                 w.Enabled=true;
                 x.Enabled=true;
                 y.Enabled=true;
                 z.Enabled=true;
                 s.Enabled=true;
                 u.Enabled=true;
                 v.Enabled=true;
                 enter.Enabled=true;
                 delete_key.Enabled=true; 
  }

  // This autoobject provides the default customization for the 'push button' widget \
  // (WidgetSet::PushButton) in its medium size variant.
  $rect <-1031,263,-791,303>
  object WidgetSet::PushButtonConfig MenuButtonConfig
  {
    preset LabelColorActive = Application::LightOrange;
    preset LabelColorFocused = Application::LightOrange;
    preset LabelColorDisabled = Application::VibrantOrange;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::LightOrange;
    preset IconTintFocused = Application::VibrantOrange;
    preset IconTintDisabled = Application::DarkOrange;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Resources::FontLarge;
    preset WidgetMinSize = <34,34>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset StackingPriority = 2;
    preset Bounds = <-24,-5,98,89>;
    preset OnPress = OpenMenu;
    preset Icon = Application::open_menu;
    preset Label = "";
    preset Appearance = MenuButtonConfig;
  }

  $rect <-1241,630,-1041,670>
  slot OpenMenu
  {
    //BlackFilterBlackFilter.Visible=true;
    //GetRoot().PresentDialog( new Application::Menu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
    GetRoot().PresentDialog( new Application::GuessTheWordMenu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  $rect <-1010,416,-810,456>
  object Core::KeyPressHandler LetterKeyHandler
  {
    preset OnPress = PressLetter;
    preset Filter = Core::KeyCode.AlphaKeys;
  }

  $rect <-1010,366,-810,406>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = PressDelete;
    preset Filter = Core::KeyCode.Delete;
  }

  $rect <-1220,366,-1020,406>
  object Core::KeyPressHandler EnterKeyHandler
  {
    preset OnPress = GuessWord;
    preset Filter = Core::KeyCode.F1;
  }

  $rect <-1220,416,-1020,456>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = PressDelete;
    preset Filter = Core::KeyCode.Backspace;
  }

  $rect <-1231,520,-1031,560>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = RevealFilter;
    preset Bounces = 3;
    preset Oscillations = 1;
    preset Value2 = #CCC0AF5F;
    preset Value1 = Application::SandColor;
    preset Outlet = ^FilterKeyboard.TintColor;
  }

  $rect <-1241,580,-1031,620>
  object Core::Timer RevealFilterTimer
  {
    preset OnTrigger = RevealFilter;
    preset Period = 0;
    preset Begin = 200;
  }

  $rect <-750,650,-520,690>
  slot RevealFilter
  {
    FilterEffect.Enabled=true;
    FilterKeyboard.Visible=true;
    ColorEffect.Enabled=true;
    DisableEffectTimer.Enabled=true;



  }

  $rect <-1011,580,-811,620>
  object Core::Timer DisableEffectTimer
  {
    preset OnTrigger = DisableEffect;
    preset Begin = 1500;
  }

  $rect <-1021,630,-811,670>
  slot DisableEffect
  {
    FilterEffect.Enabled=false;
    ColorEffect.Enabled=false;
  }

  $rect <-1011,520,-811,560>
  object Effects::ColorEffect ColorEffect
  {
    preset Value1 = Application::SandColor;
    preset Outlet = ^GuessedText.Color;
  }

  // Reveal win effect
  note group RevealWinEffectNote
  {
    attr Bounds = <-1251,480,-791,690>;
  }

  // Physical keyboard
  note group PhysicalKeyboardNote
  {
    attr Bounds = <-1250,330,-790,470>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Image
  $member Image1
  $member Image2
  $member Image3
  $member FirstLetter
  $member SecondLetter
  $member ThirdLetter
  $member ForthLetter
  $member q
  $member TransparentButton
  $member m
  $member w
  $member e
  $member r
  $member t
  $member y
  $member u
  $member i
  $member o
  $member p
  $member A
  $member s
  $member d
  $member f
  $member g
  $member h
  $member j
  $member k
  $member GuessedLettersNote
  $member NoteGameLogic
  $member GuessedText
  $member GuessWord
  $member RandomChoice
  $member Keyboard
  $member GuessWordGame
  $member WordChoices
  $member GuessedLetters
  $member delete_key
  $member enter
  $member l
  $member z
  $member x
  $member c
  $member v
  $member b
  $member n
  $member UnfilledSpaces
  $member TimerUnfilledSpaces
  $member UnfilledSpacesSlot
  $member DismissUnfilledSpacesWarning
  $member PressDelete
  $member PressLetter
  $member UnfilledSpacesGradient
  $member SpecialEffects
  $member ButtonPressed
  $member HandlingUnfilledSpaces
  $member HandlingButtonPressed
  $member PressButtonEffect
  $member FilterKeyboard
  $member DisableKeyboard
  $member EnableKeyboard
  $member MenuButtonConfig
  $member MenuButton
  $member OpenMenu
  $member LetterKeyHandler
  $member DeleteKeyHandler
  $member EnterKeyHandler
  $member BackspaceKeyHandler
  $member FilterEffect
  $member RevealFilterTimer
  $member RevealFilter
  $member DisableEffectTimer
  $member DisableEffect
  $member ColorEffect
  $member RevealWinEffectNote
  $member PhysicalKeyboardNote
}

$rect <740,830,980,870>
$output false
resource Resources::Bitmap PlaceholderGuessingGame
{
  attr bitmapfile FileName = .\placeholder_guessing_game2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Keyboard
note group Keyboard
{
  attr Bounds = <710,50,1860,390>;
}

$rect <790,90,990,130>
$output false
resource Resources::Bitmap q
{
  attr bitmapfile FileName = .\q.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,140,1850,180>
$output false
resource Resources::Bitmap m
{
  attr bitmapfile FileName = .\m.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,140,990,180>
$output false
resource Resources::Bitmap w
{
  attr bitmapfile FileName = .\w.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,190,990,230>
$output false
resource Resources::Bitmap e
{
  attr bitmapfile FileName = .\e.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,240,990,280>
$output false
resource Resources::Bitmap r
{
  attr bitmapfile FileName = .\r.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,290,990,330>
$output false
resource Resources::Bitmap t
{
  attr bitmapfile FileName = .\t.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,340,990,380>
$output false
resource Resources::Bitmap y
{
  attr bitmapfile FileName = .\y.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,90,1220,130>
$output false
resource Resources::Bitmap u
{
  attr bitmapfile FileName = .\u.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,140,1220,180>
$output false
resource Resources::Bitmap i
{
  attr bitmapfile FileName = .\i.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,190,1220,230>
$output false
resource Resources::Bitmap o
{
  attr bitmapfile FileName = .\o.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,240,1220,280>
$output false
resource Resources::Bitmap p
{
  attr bitmapfile FileName = .\p.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,290,1220,330>
$output false
resource Resources::Bitmap a
{
  attr bitmapfile FileName = .\a.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,340,1220,380>
$output false
resource Resources::Bitmap s
{
  attr bitmapfile FileName = .\s.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,90,1430,130>
$output false
resource Resources::Bitmap d
{
  attr bitmapfile FileName = .\d.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,140,1430,180>
$output false
resource Resources::Bitmap f
{
  attr bitmapfile FileName = .\f.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,190,1430,230>
$output false
resource Resources::Bitmap g
{
  attr bitmapfile FileName = .\g.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,240,1430,280>
$output false
resource Resources::Bitmap h
{
  attr bitmapfile FileName = .\h.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,290,1430,330>
$output false
resource Resources::Bitmap j
{
  attr bitmapfile FileName = .\j.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,340,1430,380>
$output false
resource Resources::Bitmap k
{
  attr bitmapfile FileName = .\k.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,90,1640,130>
$output false
resource Resources::Bitmap l
{
  attr bitmapfile FileName = .\l.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,140,1640,180>
$output false
resource Resources::Bitmap z
{
  attr bitmapfile FileName = .\z.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,190,1640,230>
$output false
resource Resources::Bitmap x
{
  attr bitmapfile FileName = .\x.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,240,1640,280>
$output false
resource Resources::Bitmap c
{
  attr bitmapfile FileName = .\c.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,290,1640,330>
$output false
resource Resources::Bitmap v
{
  attr bitmapfile FileName = .\v.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,340,1640,380>
$output false
resource Resources::Bitmap b
{
  attr bitmapfile FileName = .\b.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,90,1850,130>
$output false
resource Resources::Bitmap n
{
  attr bitmapfile FileName = .\n.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,190,1850,230>
$output false
resource Resources::Bitmap delete_key
{
  attr bitmapfile FileName = .\delete.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,240,1850,280>
$output false
resource Resources::Bitmap enter
{
  attr bitmapfile FileName = .\enter.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1420,1030,1660,1070>
$output false
resource Resources::Font WordGuessingGameFont
{
  attr fontname FontName = Constantia;
  attr fontheight Height = 32;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <740,510,980,550>
$output false
resource Resources::Bitmap OnPressWordGuessingLogo
{
  attr bitmapfile FileName = .\second_icon_guessinggame_for_pressed.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1420,1080,1660,1120>
$output false
resource Resources::Font WordGuessingGameFontWin
{
  attr fontname FontName = Constantia;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

// Fonts
note group Fonts
{
  attr Bounds = <1390,940,1690,1180>;
}

// Logos
note group Logos
{
  attr Bounds = <710,420,1010,760>;
}

$rect <740,560,980,600>
$output false
resource Resources::Bitmap MemoryGameLogo
{
  attr bitmapfile FileName = .\button_memory_game3.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <740,610,980,650>
$output false
resource Resources::Bitmap OnPressMemoryGameLogo
{
  attr bitmapfile FileName = .\icon_memory_game_after_pressed3.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1986,990,2186,1030>
$output false
class MemoryGame : Core::Group
{
  $rect <-518,540,-318,580>
  inherited property Bounds = <0,0,800,480>;

  $rect <-518,480,-318,520>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-518,440,-318,480>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-810,490,-570,530>
  object WidgetSet::PushButtonConfig PushButtonConfig;

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstLabyrinth
  {
    preset Bounds = <102,36,230,168>;
    preset OnPress = FirstLabyrinthPressed;
    preset ResignAfterHorizontalWipe = false;
    preset Icon = Application::Labyrinth;
    preset Label = "labyrinth1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstBlackLeaves
  {
    preset Bounds = <261,36,399,168>;
    preset OnPress = FirstBlackLeavesPressed;
    preset Icon = Application::BlackLeaves;
    preset Label = "blackleave1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstPendant
  {
    preset Bounds = <415,38,552,168>;
    preset OnPress = FirstPendantPressed;
    preset Icon = Application::Pandant;
    preset Label = "pandant1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstCoins
  {
    preset Bounds = <571,36,710,168>;
    preset OnPress = FirstCoinsPressed;
    preset Icon = Application::WhiteCoins;
    preset Label = "whitecoins1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondCoins
  {
    preset Bounds = <98,166,233,306>;
    preset OnPress = SecondCoinsPressed;
    preset Icon = Application::WhiteCoins;
    preset Label = "whitecoins2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstCup
  {
    preset Bounds = <260,168,398,308>;
    preset OnPress = FirstCupPressed;
    preset Icon = Application::cup;
    preset Label = "cup1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstGoldLeaves
  {
    preset Bounds = <418,168,554,308>;
    preset OnPress = FirstGoldLeavesPressed;
    preset Icon = Application::GoldLeaves;
    preset Label = "goldleaves1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondCup
  {
    preset Bounds = <567,168,706,308>;
    preset OnPress = SecondCupPressed;
    preset Icon = Application::cup;
    preset Label = "cup2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondGoldLeaves
  {
    preset Bounds = <98,314,233,452>;
    preset OnPress = SecondGoldLeavesPressed;
    preset Icon = Application::GoldLeaves;
    preset Label = "goldleaves2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondPendant
  {
    preset Bounds = <260,314,398,452>;
    preset OnPress = SecondPendantPressed;
    preset Icon = Application::Pandant;
    preset Label = "pandant2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondLabyrinth
  {
    preset Bounds = <416,304,553,463>;
    preset OnPress = SecondLabyrinthPressed;
    preset Icon = Application::Labyrinth;
    preset Label = "labyrinth2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondBlackLeaves
  {
    preset Bounds = <567,302,706,463>;
    preset OnPress = SecondBlackLeavesPressed;
    preset Icon = Application::BlackLeaves;
    preset Label = "blackleave2";
    preset Appearance = PushButtonConfig;
  }

  $rect <-1250,190,-1050,230>
  inherited method Init()
  {
    OpeningGameTimer.Enabled=true;
  }

  // Game logic
  note group GameLogic
  {
    attr Bounds = <-1350,-20,-70,430>;
  }

  // Designs and effects
  note group Design
  {
    attr Bounds = <-840,450,-540,650>;
  }

  // The logic for the first show of cards
  note group FirstShowOfCards
  {
    attr Bounds = <-1300,50,-1000,250>;
  }

  $rect <-1250,90,-1050,130>
  object Core::Timer OpeningGameTimer
  {
    preset OnTrigger = OpeningGame;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-1250,140,-1050,180>
  slot OpeningGame
  {
    FirstLabyrinth.Icon=Application::GoldPicture;
    SecondLabyrinth.Icon=Application::GoldPicture;
    FirstBlackLeaves.Icon=Application::GoldPicture;
    SecondBlackLeaves.Icon=Application::GoldPicture;
    FirstPendant.Icon=Application::GoldPicture;
    SecondPendant.Icon=Application::GoldPicture;
    FirstCoins.Icon=Application::GoldPicture;
    SecondCoins.Icon=Application::GoldPicture;
    FirstCup.Icon=Application::GoldPicture;
    SecondCup.Icon=Application::GoldPicture;
    FirstGoldLeaves.Icon=Application::GoldPicture;
    SecondGoldLeaves.Icon=Application::GoldPicture;

  }

  $rect <-940,90,-720,130>
  slot CountActiveCards
  {
    var int32 initialCount=0;

    if(FirstLabyrinth.Icon!=Application::GoldPicture)    initialCount++;

    if(SecondLabyrinth.Icon!=Application::GoldPicture)     initialCount++;
    if(FirstBlackLeaves.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondBlackLeaves.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstPendant.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondPendant.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstCoins.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondCoins.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstCup.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondCup.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstGoldLeaves.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondGoldLeaves.Icon!=Application::GoldPicture)    initialCount++;

    NumberDifferentPictures=initialCount;

  }

  // Cards management
  note group ManageCards
  {
    attr Bounds = <-970,50,-110,410>;
  }

  $rect <-940,180,-700,220>
  slot FirstLabyrinthPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstLabyrinth.Icon=Application::Labyrinth;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;


  }

  $rect <-940,230,-700,270>
  slot SecondLabyrinthPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondLabyrinth.Icon=Application::Labyrinth;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  // Revealing cards
  note group RevealingCards
  {
    attr Bounds = <-960,140,-140,390>;
  }

  $rect <-939,280,-700,320>
  slot FirstBlackLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstBlackLeaves.Icon=Application::BlackLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-940,330,-700,370>
  slot SecondBlackLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondBlackLeaves.Icon=Application::BlackLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-670,180,-430,220>
  slot FirstCupPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstCup.Icon=Application::cup;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-670,230,-430,270>
  slot SecondCupPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondCup.Icon=Application::cup;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-669,280,-430,320>
  slot FirstPendantPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstPendant.Icon=Application::Pandant;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-670,330,-430,370>
  slot SecondPendantPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondPendant.Icon=Application::Pandant;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-410,180,-170,220>
  slot FirstCoinsPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstCoins.Icon=Application::WhiteCoins;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-410,230,-170,270>
  slot SecondCoinsPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondCoins.Icon=Application::WhiteCoins;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-409,280,-170,320>
  slot FirstGoldLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstGoldLeaves.Icon=Application::GoldLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-410,330,-170,370>
  slot SecondGoldLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondGoldLeaves.Icon=Application::GoldLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    var slot sl2=this.Schaffle;
    signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-710,90,-510,130>
  slot VerifyCards
  {
    if(NumberDifferentPictures%2==0)
    {
    //if((FirstLabyrinth.Icon==Application::Labyrinth && SecondLabyrinth.Icon==Application::Labyrinth) || (SecondBlackLeaves.Icon==Application::BlackLeaves && FirstBlackLeaves.Icon==Application::BlackLeaves) || (FirstPendant.Icon==Application::Pandant && SecondPendant.Icon==Application::Pandant) || (FirstCoins.Icon==Application::WhiteCoins && SecondCoins.Icon==Application::WhiteCoins) || (FirstCup.Icon==Application::cup && SecondCup.Icon==Application::cup) || (FirstGoldLeaves.Icon==Application::GoldLeaves && SecondGoldLeaves.Icon==Application::GoldLeaves))
    //{
        if(FirstLabyrinth.Icon!=Application::Labyrinth || SecondLabyrinth.Icon!=Application::Labyrinth)
        {
        FirstLabyrinth.Icon=Application::GoldPicture;
        SecondLabyrinth.Icon=Application::GoldPicture;
        }

        if(SecondBlackLeaves.Icon!=Application::BlackLeaves || FirstBlackLeaves.Icon!=Application::BlackLeaves)
        {
        FirstBlackLeaves.Icon=Application::GoldPicture;
        SecondBlackLeaves.Icon=Application::GoldPicture;
        }

            if(FirstPendant.Icon!=Application::Pandant || SecondPendant.Icon!=Application::Pandant)
        {
        FirstPendant.Icon=Application::GoldPicture;
        SecondPendant.Icon=Application::GoldPicture;
        }

            if(FirstCup.Icon!=Application::cup || SecondCup.Icon!=Application::cup)
        {
        FirstCup.Icon=Application::GoldPicture;
        SecondCup.Icon=Application::GoldPicture;
        }

            if(FirstCoins.Icon!=Application::WhiteCoins || SecondCoins.Icon!=Application::WhiteCoins)
        {
        FirstCoins.Icon=Application::GoldPicture;
        SecondCoins.Icon=Application::GoldPicture;
        }

            if(FirstGoldLeaves.Icon!=Application::GoldLeaves || SecondGoldLeaves.Icon!=Application::GoldLeaves)
        {
        FirstGoldLeaves.Icon=Application::GoldPicture;
        SecondGoldLeaves.Icon=Application::GoldPicture;
        }

    //}   
    //else
    //{
    //
    //}

    NumberDifferentPictures=0;

    var slot sl=this.WinMessage;
    signal sl;
    }
  }

  $rect <-520,600,-300,640>
  var int32 NumberDifferentPictures;

  $rect <-490,90,-290,130>
  object Core::Timer RevealCardTimer
  {
    preset OnTrigger = VerifyCards;
    preset Period = 0;
    preset Begin = 500;
  }

  $rect <-1260,270,-1060,310>
  slot WinMessage
  {
    if(FirstLabyrinth.Icon==Application::Labyrinth && SecondLabyrinth.Icon==Application::Labyrinth && FirstCup.Icon==Application::cup && SecondCup.Icon==Application::cup && FirstPendant.Icon==Application::Pandant && SecondPendant.Icon==Application::Pandant && FirstBlackLeaves.Icon==Application::BlackLeaves && SecondBlackLeaves.Icon==Application::BlackLeaves && FirstCoins.Icon==Application::WhiteCoins && SecondCoins.Icon==Application::WhiteCoins && FirstGoldLeaves.Icon==Application::GoldLeaves && SecondGoldLeaves.Icon==Application::GoldLeaves)
       {
       //FilterKeyboard.Visible=true;
       //GuessedText.Visible=true;
       RevealFilterTimer.Enabled=true;
       }
  }

  $rect <20,20,160,60>
  object Views::Text GuessedText
  {
    preset StackingPriority = 5;
    preset Bounds = <164,86,667,386>;
    preset Padding = 0;
    preset ColorBL = #FFFBF6FF;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You won!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Color = #FFF36AFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::FilterImage FilterKeyboard
  {
    preset Bounds = <86,36,747,453>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = #CCC0AFFF;
    preset TintIntensity = 9.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 140;
    preset Visible = false;
  }

  $rect <-790,540,-590,580>
  slot Schaffle
  {
    //
    //  var int canvasWidth = 320;
    //  var int canvasHeight = 240;
    //  var int buttonWidth = 50;
    //  var int buttonHeight = 30;
    //
    //  // Generate random positions within the canvas bounds
    //  var int newX = Math::RandomInt32( 0, canvasWidth - buttonWidth );
    //  var int newY = Math::RandomInt32( 0, canvasHeight - buttonHeight );
    //
    //  // Set the new position using Core::Rect
    //  this.Bounds = Core::Rect( newX, newY, newX + buttonWidth, newY + buttonHeight );


  }

  $rect <-290,470,-90,510>
  property int32 Rotate;

  $rect <-290,510,-90,550>
  onset Rotate
  {
    // The value doesn't change - nothing to do.
    if ( pure Rotate == value )
      return;

    // Remember the property's new value.
    pure Rotate = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <-290,550,-90,590>
  onget Rotate
  {
    return pure Rotate;
  }

  $rect <-1260,330,-1060,370>
  slot OpenMenu
  {
    //BlackFilterBlackFilter.Visible=true;
    //GetRoot().PresentDialog( new Application::Menu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
    GetRoot().PresentDialog( new Application::GuessTheWordMenu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  // This autoobject provides the default customization for the 'push button' widget \
  // (WidgetSet::PushButton) in its medium size variant.
  $rect <-820,590,-580,630>
  object WidgetSet::PushButtonConfig MenuButtonConfig
  {
    preset LabelColorActive = Application::LightOrange;
    preset LabelColorFocused = Application::LightOrange;
    preset LabelColorDisabled = Application::VibrantOrange;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::LightOrange;
    preset IconTintFocused = Application::VibrantOrange;
    preset IconTintDisabled = Application::DarkOrange;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Resources::FontLarge;
    preset WidgetMinSize = <34,34>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset StackingPriority = 2;
    preset Bounds = <-28,-21,86,69>;
    preset OnPress = OpenMenu;
    preset Icon = Application::open_menu;
    preset Label = "";
    preset Appearance = MenuButtonConfig;
  }

  $rect <-1320,490,-1120,530>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = RevealFilter;
    preset Bounces = 3;
    preset Oscillations = 1;
    preset Value2 = #CCC0AF6E;
    preset Value1 = Application::SandColor;
    preset Outlet = ^FilterKeyboard.TintColor;
  }

  $rect <-1100,490,-920,530>
  object Core::Timer RevealFilterTimer
  {
    preset OnTrigger = RevealFilter;
    preset Period = 0;
    preset Begin = 200;
  }

  $rect <-1330,590,-1130,630>
  slot RevealFilter
  {
    FilterEffect.Enabled=true;
    FilterKeyboard.Visible=true;
    ColorEffect.Enabled=true;
    GuessedText.Visible=true;
    DisableEffectTimer.Enabled=true;



  }

  $rect <-1100,540,-920,580>
  object Core::Timer DisableEffectTimer
  {
    preset OnTrigger = DisableEffect;
    preset Begin = 1500;
  }

  $rect <-1110,590,-920,630>
  slot DisableEffect
  {
    FilterEffect.Enabled=false;
    ColorEffect.Enabled=false;
  }

  $rect <-1320,540,-1120,580>
  object Effects::ColorEffect ColorEffect
  {
    preset Value2 = #FFFFFFFF;
    preset Value1 = Application::SandColor;
    preset Outlet = ^GuessedText.Color;
  }

  // Reveal win effect
  note group RevealWinEffectNote
  {
    attr Bounds = <-1340,450,-880,650>;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member PushButtonConfig
  $member FirstLabyrinth
  $member FirstBlackLeaves
  $member FirstPendant
  $member FirstCoins
  $member SecondCoins
  $member FirstCup
  $member FirstGoldLeaves
  $member SecondCup
  $member SecondGoldLeaves
  $member SecondPendant
  $member SecondLabyrinth
  $member SecondBlackLeaves
  $member GameLogic
  $member Design
  $member FirstShowOfCards
  $member OpeningGameTimer
  $member OpeningGame
  $member CountActiveCards
  $member ManageCards
  $member FirstLabyrinthPressed
  $member SecondLabyrinthPressed
  $member RevealingCards
  $member FirstBlackLeavesPressed
  $member SecondBlackLeavesPressed
  $member FirstCupPressed
  $member SecondCupPressed
  $member FirstPendantPressed
  $member SecondPendantPressed
  $member FirstCoinsPressed
  $member SecondCoinsPressed
  $member FirstGoldLeavesPressed
  $member SecondGoldLeavesPressed
  $member VerifyCards
  $member NumberDifferentPictures
  $member RevealCardTimer
  $member WinMessage
  $member GuessedText
  $member FilterKeyboard
  $member Schaffle
  $member Rotate
  $member OnSetRotate
  $member OnGetRotate
  $member OpenMenu
  $member MenuButtonConfig
  $member MenuButton
  $member FilterEffect
  $member RevealFilterTimer
  $member RevealFilter
  $member DisableEffectTimer
  $member DisableEffect
  $member ColorEffect
  $member RevealWinEffectNote
}

$rect <1050,460,1250,500>
$output false
resource Resources::Bitmap cup
{
  attr bitmapfile FileName = .\cup6.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Images memory game
note group Note3
{
  attr Bounds = <1030,420,1330,810>;
}

$rect <1050,510,1250,550>
$output false
resource Resources::Bitmap WhiteCoins
{
  attr bitmapfile FileName = .\coins_background.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,560,1250,600>
$output false
resource Resources::Bitmap BlackLeaves
{
  attr bitmapfile FileName = .\golden_leaves_black_image1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,610,1250,650>
$output false
resource Resources::Bitmap GoldLeaves
{
  attr bitmapfile FileName = .\golden_leaves_gold_image1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,660,1250,700>
$output false
resource Resources::Bitmap Pandant
{
  attr bitmapfile FileName = .\pandant_picture2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,710,1250,750>
$output false
resource Resources::Bitmap Labyrinth
{
  attr bitmapfile FileName = .\labyrinth_picture1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,760,1250,800>
$output false
resource Resources::Bitmap GoldPicture
{
  attr bitmapfile FileName = .\blank_picture1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <740,660,980,700>
$output false
resource Resources::Bitmap TilesPuzzleLogo
{
  attr bitmapfile FileName = .\logo_tiles_puzzle1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <740,710,980,750>
$output false
resource Resources::Bitmap OnPressTilesPuzzleLogo
{
  attr bitmapfile FileName = .\on_press_tiles_puzzle_logo1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1986,1040,2186,1080>
$output false
class TilesPuzzle : Core::Group
{
  $rect <-960,740,-760,780>
  inherited property Bounds = <0,0,800,480>;

  $rect <-500,740,-300,780>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-720,740,-520,780>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <73,-17,702,480>;
    preset Bitmap = Application::Frame;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstTile
  {
    preset Bounds = <241,80,322,165>;
    preset OnPress = FirstTileMovement;
    preset Icon = Application::NinthTile;
    preset Label = "1";
    preset Appearance = TransparentButton;
  }

  $rect <-1670,750,-1430,790>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <20,20,160,60>
  object WidgetSet::PushButton FourthTile
  {
    preset Bounds = <484,82,565,162>;
    preset OnPress = FourthTileMovement;
    preset Icon = Application::ThirthTile;
    preset Label = "4";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ThirdTile
  {
    preset Bounds = <403,82,484,162>;
    preset OnPress = ThirdTileMovement;
    preset Icon = Application::EleventhTile;
    preset Label = "3";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondTile
  {
    preset Bounds = <322,80,403,162>;
    preset OnPress = SecondTileMovement;
    preset Icon = Application::FirstTile;
    preset Label = "2";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FifthTile
  {
    preset Bounds = <240,161,321,246>;
    preset OnPress = FifthTileMovement;
    preset Icon = Application::TenthTile;
    preset Label = "5";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton NinthTile
  {
    preset Bounds = <241,243,322,328>;
    preset OnRelease = null;
    preset OnPress = NinthTileMovement;
    preset Icon = Application::ThirteenTile;
    preset Label = "9";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ThirteenthTile
  {
    preset Bounds = <241,324,322,409>;
    preset OnPress = ThirteenthTileMovement;
    preset Icon = Application::ForteenthTile;
    preset Label = "13";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SixthTile
  {
    preset Bounds = <322,161,403,246>;
    preset OnPress = SixthTileMovement;
    preset Icon = Application::SecondTile;
    preset Label = "6";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SeventhTile
  {
    preset Bounds = <403,160,484,245>;
    preset OnPress = SeventhTileMovement;
    preset Icon = Application::SixthTile;
    preset Label = "7";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton EighthTile
  {
    preset Bounds = <485,160,566,245>;
    preset OnPress = EighthTileMovement;
    preset Icon = Application::ForthTile;
    preset Label = "8";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TenthTile
  {
    preset Bounds = <322,244,403,325>;
    preset OnPress = TenthTileMovement;
    preset Icon = Application::BackgroudGamingRoom;
    preset Label = "10";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton EleventhTile
  {
    preset Bounds = <404,243,485,328>;
    preset OnPress = EleventhTileMovement;
    preset Icon = Application::FifthTile;
    preset Label = "11";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TwelfthTile
  {
    preset Bounds = <485,242,566,327>;
    preset OnPress = TwelfthTileMovement;
    preset Icon = Application::SeventhTile;
    preset Label = "12";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FourteenthTile
  {
    preset Bounds = <323,323,404,408>;
    preset OnPress = FourteenthTileMovement;
    preset Icon = Application::FifteenthTile;
    preset Label = "14";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FifteenthTile
  {
    preset Bounds = <403,325,484,410>;
    preset OnPress = FifteenthTileMovement;
    preset Icon = Application::EighthTile;
    preset Label = "15";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SixteenthTile
  {
    preset Bounds = <485,324,566,409>;
    preset OnPress = SixteenthTileMovement;
    preset Icon = Application::TwelfthTile;
    preset Label = "16";
    preset Appearance = TransparentButton;
  }

  $rect <-930,110,-730,150>
  var int32 FirstPos = 9;

  $rect <-929,160,-729,200>
  var int32 SecondPos = 1;

  $rect <-930,260,-730,300>
  var int32 FourthPos = 3;

  $rect <-710,110,-510,150>
  var int32 FifthPos = 10;

  $rect <-710,160,-510,200>
  var int32 SixthPos = 2;

  $rect <-710,210,-510,250>
  var int32 SeventhPos = 6;

  $rect <-710,260,-510,300>
  var int32 EighthPos = 4;

  $rect <-490,110,-290,150>
  var int32 NinthPos = 13;

  $rect <-490,160,-290,200>
  var int32 TenthPos = 0;

  $rect <-490,210,-290,250>
  var int32 EleventhPos = 5;

  $rect <-490,260,-290,300>
  var int32 TwelfthPos = 7;

  $rect <-270,110,-70,150>
  var int32 ThirteenthPos = 14;

  $rect <-270,160,-70,200>
  var int32 FourteenthPos = 15;

  $rect <-270,210,-70,250>
  var int32 FifteenthPos = 8;

  $rect <-930,210,-730,250>
  var int32 ThirdPos = 11;

  // Tiles' positions
  note group TilesPositions
  {
    attr Bounds = <-970,50,-40,330>;
  }

  // Tiles' movement
  note group TilesMovement
  {
    attr Bounds = <-970,340,-40,640>;
  }

  $rect <-270,260,-70,300>
  var int32 SixteenthPos = 12;

  $rect <20,20,160,60>
  object Views::Text GuessedText
  {
    preset StackingPriority = 3;
    preset Bounds = <149,90,652,390>;
    preset Padding = 0;
    preset OnUpdate = null;
    preset ColorBL = #FFFBF6FF;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You won!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Color = #FFF36AFF;
    preset Visible = false;
  }

  $rect <-940,390,-740,430>
  slot FirstTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SecondPos==0)
    {
    SecondPos=FirstPos;
    FirstPos=0;
    SecondTile.Icon=FirstTile.Icon;
    FirstTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FifthPos==0)
    {
    FifthPos=FirstPos;
    FirstPos=0;
    FifthTile.Icon=FirstTile.Icon;
    FirstTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-940,440,-740,480>
  slot SecondTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FirstPos==0)
    {
    FirstPos=SecondPos;
    SecondPos=0;
    FirstTile.Icon=SecondTile.Icon;
    SecondTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SixthPos==0)
    {
    SixthPos=SecondPos;
    SecondPos=0;
    SixthTile.Icon=SecondTile.Icon;
    SecondTile.Icon=Application::BackgroudGamingRoom;
    }

    if(ThirdPos==0)
    {
    ThirdPos=SecondPos;
    SecondPos=0;
    ThirdTile.Icon=SecondTile.Icon;
    SecondTile.Icon=Application::BackgroudGamingRoom;
    }


    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-940,490,-740,530>
  slot ThirdTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SecondPos==0)
    {
    SecondPos=ThirdPos;
    ThirdPos=0;
    SecondTile.Icon=ThirdTile.Icon;
    ThirdTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=ThirdPos;
    ThirdPos=0;
    SeventhTile.Icon=ThirdTile.Icon;
    ThirdTile.Icon=Application::BackgroudGamingRoom;
    }


    if(FourthPos==0)
    {
    FourthPos=ThirdPos;
    ThirdPos=0;
    FourthTile.Icon=ThirdTile.Icon;
    ThirdTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-940,540,-740,580>
  slot FourthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(ThirdPos==0)
    {
    ThirdPos=FourthPos;
    FourthPos=0;
    ThirdTile.Icon=FourthTile.Icon;
    FourthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EighthPos==0)
    {
    EighthPos=FourthPos;
    FourthPos=0;
    EighthTile.Icon=FourthTile.Icon;
    FourthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,390,-520,430>
  slot FifthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FirstPos==0)
    {
    FirstPos=FifthPos;
    FifthPos=0;
    FirstTile.Icon=FifthTile.Icon;
    FifthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SixthPos==0)
    {
    SixthPos=FifthPos;
    FifthPos=0;
    SixthTile.Icon=FifthTile.Icon;
    FifthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(NinthPos==0)
    {
    NinthPos=FifthPos;
    FifthPos=0;
    NinthTile.Icon=FifthTile.Icon;
    FifthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,440,-520,480>
  slot SixthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SecondPos==0)
    {
    SecondPos=SixthPos;
    SixthPos=0;
    SecondTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FifthPos==0)
    {
    FifthPos=SixthPos;
    SixthPos=0;
    FifthTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=SixthPos;
    SixthPos=0;
    SeventhTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=SixthPos;
    SixthPos=0;
    TenthTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,490,-520,530>
  slot SeventhTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(ThirdPos==0)
    {
    ThirdPos=SeventhPos;
    SeventhPos=0;
    ThirdTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SixthPos==0)
    {
    SixthPos=SeventhPos;
    SeventhPos=0;
    SixthTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EighthPos==0)
    {
    EighthPos=SeventhPos;
    SeventhPos=0;
    EighthTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EleventhPos==0)
    {
    EleventhPos=SeventhPos;
    SeventhPos=0;
    EleventhTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,540,-520,580>
  slot EighthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(TwelfthPos==0)
    {
    TwelfthPos=EighthPos;
    EighthPos=0;
    TwelfthTile.Icon=EighthTile.Icon;
    EighthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=EighthPos;
    EighthPos=0;
    SeventhTile.Icon=EighthTile.Icon;
    EighthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FourthPos==0)
    {
    FourthPos=EighthPos;
    EighthPos=0;
    FourthTile.Icon=EighthTile.Icon;
    EighthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,390,-300,430>
  slot NinthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifthPos==0)
    {
    FifthPos=NinthPos;
    NinthPos=0;
    FifthTile.Icon=NinthTile.Icon;
    NinthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=NinthPos;
    NinthPos=0;
    TenthTile.Icon=NinthTile.Icon;
    NinthTile.Icon=Application::BackgroudGamingRoom;

    }

    if(ThirteenthPos==0)
    {
    ThirteenthPos=NinthPos;
    NinthPos=0;
    ThirteenthTile.Icon=NinthTile.Icon;
    NinthTile.Icon=Application::BackgroudGamingRoom;
    }


    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,440,-300,480>
  slot TenthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SixthPos==0)
    {
    SixthPos=TenthPos;
    TenthPos=0;
    SixthTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(NinthPos==0)
    {
    NinthPos=TenthPos;
    TenthPos=0;
    NinthTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EleventhPos==0)
    {
    EleventhPos=TenthPos;
    TenthPos=0;
    EleventhTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FourteenthPos==0)
    {
    FourteenthPos=TenthPos;
    TenthPos=0;
    FourteenthTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,490,-300,530>
  slot EleventhTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifteenthPos==0)
    {
    FifteenthPos=EleventhPos;
    EleventhPos=0;
    FifteenthTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;

    }

           //not tested yet
    if(TwelfthPos==0)
    {
    TwelfthPos=EleventhPos;
    EleventhPos=0;
    TwelfthTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=EleventhPos;
    EleventhPos=0;
    TenthTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=EleventhPos;
    EleventhPos=0;
    SeventhTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,540,-300,580>
  slot TwelfthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SixteenthPos==0)
    {
    SixteenthPos=TwelfthPos;
    TwelfthPos=0;
    SixteenthTile.Icon=TwelfthTile.Icon;
    TwelfthTile.Icon=Application::BackgroudGamingRoom;
    }

        //unverified
    if(EighthPos==0)
    {
    EighthPos=TwelfthPos;
    TwelfthPos=0;
    EighthTile.Icon=TwelfthTile.Icon;
    TwelfthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EleventhPos==0)
    {
    EleventhPos=TwelfthPos;
    TwelfthPos=0;
    EleventhTile.Icon=TwelfthTile.Icon;
    TwelfthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,390,-70,430>
  slot ThirteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FourteenthPos==0)
    {
    FourteenthPos=ThirteenthPos;
    ThirteenthPos=0;
    FourteenthTile.Icon=ThirteenthTile.Icon;
    ThirteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(NinthPos==0)
    {
    NinthPos=ThirteenthPos;
    ThirteenthPos=0;
    NinthTile.Icon=ThirteenthTile.Icon;
    ThirteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,440,-70,480>
  slot FourteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifteenthPos==0)
    {
    FifteenthPos=FourteenthPos;
    FourteenthPos=0;
    FifteenthTile.Icon=FourteenthTile.Icon;
    FourteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=FourteenthPos;
    FourteenthPos=0;
    TenthTile.Icon=FourteenthTile.Icon;
    FourteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(ThirteenthPos==0)
    {
    ThirteenthPos=FourteenthPos;
    FourteenthPos=0;
    ThirteenthTile.Icon=FourteenthTile.Icon;
    FourteenthTile.Icon=Application::BackgroudGamingRoom;
    }



    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,490,-70,530>
  slot FifteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SixteenthPos==0)
    {
    SixteenthPos=FifteenthPos;
    FifteenthPos=0;
    SixteenthTile.Icon=FifteenthTile.Icon;
    FifteenthTile.Icon=Application::BackgroudGamingRoom;

    }

    if(EleventhPos==0)
    {
    EleventhPos=FifteenthPos;
    FifteenthPos=0;
    EleventhTile.Icon=FifteenthTile.Icon;
    FifteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FourteenthPos==0)
    {
    FourteenthPos=FifteenthPos;
    FifteenthPos=0;
    FourteenthTile.Icon=FifteenthTile.Icon;
    FifteenthTile.Icon=Application::BackgroudGamingRoom;
    }



    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,540,-70,580>
  slot SixteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifteenthPos==0)
    {
    FifteenthPos=SixteenthPos;
    SixteenthPos=0;
    FifteenthTile.Icon=SixteenthTile.Icon;
    SixteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TwelfthPos==0)
    {
    TwelfthPos=SixteenthPos;
    SixteenthPos=0;
    TwelfthTile.Icon=SixteenthTile.Icon;
    SixteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-950,660,-750,700>
  slot FindSolution
  {
    if(FirstPos==1 && SecondPos==2 && ThirdPos==3 && FourthPos==4 && FifthPos==5 && SixthPos==6 && SeventhPos==7 && EighthPos==8 && NinthPos==9 && TenthPos==10 && EleventhPos==11 && TwelfthPos==12 && ThirteenthPos==13 && FourteenthPos==14 && FifteenthPos==15 && SixteenthPos==0)
    {
    RevealTilesTimer.Enabled=true;
    }

  }

  note arrow Note
  {
    attr Point1 = <-970,90>;
    attr Point2 = <-1030,110>;
  }

  // Game logic
  note group GameLogic
  {
    attr Bounds = <-990,10,-20,720>;
  }

  // The positions are used to identify the placement of the images at any given \
  // time. They do not move, the images on them change.
  note legend PositionsLegend2
  {
    attr Bounds = <-1330,100,-1030,300>;
  }

  // Tiles' movement
  note group TilesMovement1
  {
    attr Bounds = <-970,340,-40,640>;
  }

  // Tiles' positions
  note group TilesPositions1
  {
    attr Bounds = <-970,50,-40,330>;
  }

  // Effects
  note group Effects
  {
    attr Bounds = <-1720,330,-1020,800>;
  }

  $rect <-1670,430,-1440,470>
  slot RevealCompletedPicture
  {
    Solution.Visible=true;

    RevealGuessedTextTimer.Enabled=true;
    RevealFilterTimer.Enabled=true;

  }

  $rect <-1670,480,-1440,520>
  slot RevealAllTiles
  {
    SixteenthTile.Icon=Application::SixteenthTile;
    RevealPictureTimer.Enabled=true;
  }

  // Reveal answer
  note group RevealAnswer
  {
    attr Bounds = <-1680,390,-1070,740>;
  }

  $rect <-1390,430,-1120,470>
  object Core::Timer RevealTilesTimer
  {
    preset OnTrigger = RevealAllTiles;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-1390,480,-1120,520>
  object Core::Timer RevealPictureTimer
  {
    preset OnTrigger = RevealCompletedPicture;
    preset Period = 0;
    preset Begin = 1500;
  }

  $rect <20,20,160,60>
  object Views::Image Solution
  {
    preset Bounds = <242,74,566,407>;
    preset Bitmap = Application::Medusa;
    preset Visible = false;
  }

  $rect <-1389,530,-1120,570>
  object Core::Timer RevealGuessedTextTimer
  {
    preset OnTrigger = RevealGuessedText;
    preset Period = 0;
    preset Begin = 1200;
  }

  $rect <-1670,530,-1440,570>
  slot RevealGuessedText
  {
    GuessedText.Visible=true;
    //RevealFilterTimer.Enabled=true;

  }

  $rect <20,20,160,60>
  object Views::FilterImage FilterKeyboard
  {
    preset Bounds = <235,77,566,411>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = #180E00FF;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 100;
    preset Visible = false;
  }

  $rect <-1460,690,-1260,730>
  object Effects::ColorEffect GuessedTextPulse
  {
    preset OnAnimate = FindSolution;
    preset Bounces = 6;
    preset TimingCustom2 = 0.0;
    preset TimingCustom1 = 0.0;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 6;
    preset Enabled = false;
    preset Value2 = #D2851BFF;
    preset Value1 = #F3FF00FF;
    preset Outlet = ^GuessedText.Color;
  }

  $rect <-1390,580,-1120,620>
  object Core::Timer RevealFilterTimer
  {
    preset OnTrigger = RevealFilter;
    preset Period = 0;
    preset Begin = 200;
  }

  $rect <-1670,580,-1440,620>
  slot RevealFilter
  {
    FilterEffect.Enabled=true;
    FilterKeyboard.Visible=true;
    DisableEffectTimer.Enabled=true;



  }

  $rect <-1670,690,-1470,730>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = RevealFilter;
    preset Bounces = 3;
    preset Oscillations = 1;
    preset Value2 = #000000FF;
    preset Value1 = #E8A0385D;
    preset Outlet = ^FilterKeyboard.TintColor;
  }

  $rect <-1670,630,-1440,670>
  slot DisableEffect
  {
    FilterEffect.Enabled=false;
  }

  $rect <-1390,630,-1120,670>
  object Core::Timer DisableEffectTimer
  {
    preset OnTrigger = DisableEffect;
    preset Begin = 1500;
  }

  $rect <-270,660,-70,700>
  slot OpenMenu
  {
    //BlackFilterBlackFilter.Visible=true;
    //GetRoot().PresentDialog( new Application::Menu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
    GetRoot().PresentDialog( new Application::GuessTheWordMenu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  // This autoobject provides the default customization for the 'push button' widget \
  // (WidgetSet::PushButton) in its medium size variant.
  $rect <-1410,750,-1170,790>
  object WidgetSet::PushButtonConfig MenuButtonConfig
  {
    preset LabelColorActive = Application::LightOrange;
    preset LabelColorFocused = Application::LightOrange;
    preset LabelColorDisabled = Application::VibrantOrange;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::LightOrange;
    preset IconTintFocused = Application::VibrantOrange;
    preset IconTintDisabled = Application::DarkOrange;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Resources::FontLarge;
    preset WidgetMinSize = <34,34>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset StackingPriority = 2;
    preset Bounds = <-39,-20,111,74>;
    preset OnPress = OpenMenu;
    preset Icon = Application::open_menu;
    preset Label = "";
    preset Appearance = MenuButtonConfig;
  }
}

// Images tiles puzzle
note group ImagesTilesPuzzle
{
  attr Bounds = <1360,420,2060,810>;
}

$rect <1410,480,1610,520>
$output false
resource Resources::Bitmap Frame
{
  attr bitmapfile FileName = .\frame_rectangle_picture.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,530,1610,570>
$output false
resource Resources::Bitmap FirstTile
{
  attr bitmapfile FileName = .\first_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,580,1610,620>
$output false
resource Resources::Bitmap SecondTile
{
  attr bitmapfile FileName = .\second_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,630,1610,670>
$output false
resource Resources::Bitmap ThirthTile
{
  attr bitmapfile FileName = .\third_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,680,1610,720>
$output false
resource Resources::Bitmap ForthTile
{
  attr bitmapfile FileName = .\forth_tile.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,730,1610,770>
$output false
resource Resources::Bitmap FifthTile
{
  attr bitmapfile FileName = .\fifth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,480,2030,520>
$output false
resource Resources::Bitmap TwelfthTile
{
  attr bitmapfile FileName = .\twelfth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,480,1820,520>
$output false
resource Resources::Bitmap SixthTile
{
  attr bitmapfile FileName = .\sixth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,530,1820,570>
$output false
resource Resources::Bitmap SeventhTile
{
  attr bitmapfile FileName = .\seventh_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,580,1820,620>
$output false
resource Resources::Bitmap EighthTile
{
  attr bitmapfile FileName = .\eighth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,630,1820,670>
$output false
resource Resources::Bitmap NinthTile
{
  attr bitmapfile FileName = .\ninth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,680,1820,720>
$output false
resource Resources::Bitmap TenthTile
{
  attr bitmapfile FileName = .\tenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,730,1820,770>
$output false
resource Resources::Bitmap EleventhTile
{
  attr bitmapfile FileName = .\eleventh_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,530,2030,570>
$output false
resource Resources::Bitmap ThirteenTile
{
  attr bitmapfile FileName = .\thirteenth_tile.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,580,2030,620>
$output false
resource Resources::Bitmap ForteenthTile
{
  attr bitmapfile FileName = .\forteenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,630,2030,670>
$output false
resource Resources::Bitmap FifteenthTile
{
  attr bitmapfile FileName = .\fifteenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,680,2030,720>
$output false
resource Resources::Bitmap SixteenthTile
{
  attr bitmapfile FileName = .\sixteenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1025,830,1225,870>
$output false
resource Resources::Bitmap Arrow
{
  attr bitmapfile FileName = .\arrow.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,730,2030,770>
$output false
resource Resources::Bitmap Medusa
{
  attr bitmapfile FileName = .\medusa1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Menus
note group Menus
{
  attr Bounds = <690,940,1030,1100>;
}

// Menu items
note group MenuItems
{
  attr Bounds = <1060,940,1360,1110>;
}

// This component implements a simple menu item.
$rect <1080,990,1330,1030>
$output false
class MenuItem : Templates::MenuItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       minimum width for the item.

    */

    // We assume: the item requires space for the caption and 20 pixel margin on
    // the left and on the right of the caption. Important: perform the calculation
    // without the caption text being evtl. truncated and replaced by an ellipsis
    // sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 20, 0 );
    CaptionText.Ellipsis = ellipsis;

    // Assume the min. height corresponds to the actual design height of the item.
    size.y = 40;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
    }

    else if ( isPressed )
    {
      Background.Color  = #FF0000FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // To do:
  // 
  // - Adjust the visible size of your item (the thick blue border). This will be \
  // the item's default size.
  // - Resize the member 'TouchHandler' so it still fills the items's new area.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your item.
  // - If you don't want the caption text to be shown, remove also the members 'CaptionText' \
  // and the property 'Caption' together with its 'OnSetCaption' method.
  // - According to your desired item design add and configure new views (e.g. an \
  // image view to show an icon in the item, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the item's current state.
  // - You can also add and configure animation effects to your item. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your item.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the item itself is resized.
  // - Adapt the method GetMinimalSize(). The method should calculate the minimal \
  // width the item will occupy within the menu.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // item to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your item. One property \
  // for every item specific setting (e.g. 'Icon', 'Color', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your item where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  // - If the content of the item changes, invoke Owner.InvalidateLayout() to trigger \
  // the superior menu to update the arrangement and size of the items.
  note legend Note5
  {
    attr Bounds = <10,370,990,800>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;

    // Changing the caption may affect the size of the item. Request the
    // superior menu to recalculate its layout
    if ( Owner )
      Owner.InvalidateLayout();
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
    preset Width = 3;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,210,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <480,10,680,50>
  property slot OnActivate = null;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

// This component implements a simple menu item.
$rect <1120,1040,1330,1080>
$output false
class MainMenuItem : Templates::MenuItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       minimum width for the item.

    */

    // We assume: the item requires space for the caption and 20 pixel margin on
    // the left and on the right of the caption. Important: perform the calculation
    // without the caption text being evtl. truncated and replaced by an ellipsis
    // sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 20, 0 );
    CaptionText.Ellipsis = ellipsis;

    // Assume the min. height corresponds to the actual design height of the item.
    size.y = 40;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
    }

    else if ( isPressed )
    {
      Background.Color  = #FF0000FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // To do:
  // 
  // - Adjust the visible size of your item (the thick blue border). This will be \
  // the item's default size.
  // - Resize the member 'TouchHandler' so it still fills the items's new area.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your item.
  // - If you don't want the caption text to be shown, remove also the members 'CaptionText' \
  // and the property 'Caption' together with its 'OnSetCaption' method.
  // - According to your desired item design add and configure new views (e.g. an \
  // image view to show an icon in the item, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the item's current state.
  // - You can also add and configure animation effects to your item. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your item.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the item itself is resized.
  // - Adapt the method GetMinimalSize(). The method should calculate the minimal \
  // width the item will occupy within the menu.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // item to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your item. One property \
  // for every item specific setting (e.g. 'Icon', 'Color', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your item where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  // - If the content of the item changes, invoke Owner.InvalidateLayout() to trigger \
  // the superior menu to update the arrangement and size of the items.
  note legend Note5
  {
    attr Bounds = <10,370,990,800>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;

    // Changing the caption may affect the size of the item. Request the
    // superior menu to recalculate its layout
    if ( Owner )
      Owner.InvalidateLayout();
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
    preset Width = 3;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,210,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <480,10,680,50>
  property slot OnActivate = null;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

$rect <730,990,980,1030>
$output false
class Menu : Core::Group
{
  $rect <30,1250,230,1290>
  inherited property Bounds = <0,0,800,627>;

  $rect <30,1410,230,1450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <30,1370,230,1410>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Frame
  {
    preset StackingPriority = 8;
    preset Bounds = <138,141,631,628>;
    preset Bitmap = Application::MenuFrame;
  }

  $rect <20,20,160,60>
  object Views::FilterImage BlackFilter
  {
    preset StackingPriority = 9;
    preset Bounds = <299,277,474,490>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = Application::Black;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 140;
    preset Visible = true;
  }

  $rect <-360,120,-160,160>
  slot CloseMenu
  {
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::FilterImage BlackFilterBackground
  {
    preset StackingPriority = 7;
    preset Bounds = <2,-28,803,657>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = Application::Black;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 100;
    preset Visible = true;
  }
}

$rect <750,1040,980,1080>
$output false
class GuessTheWordMenu : Application::Menu
{
  $rect <-10,2420,190,2460>
  inherited property Bounds = <0,0,800,486>;

  $rect <-10,2580,190,2620>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-10,2540,190,2580>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-290,410,-50,450>
  object WidgetSet::PushButtonConfig ButtonConfig
  {
    preset LabelColorActive = Application::VibrantOrange;
    preset LabelColorFocused = Application::Black;
    preset LabelColorDisabled = Application::Black;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::VibrantOrange;
    preset IconTintFocused = Application::Black;
    preset IconTintDisabled = Application::Black;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Application::WordGuessingGameSmallFont;
  }

  $rect <-540,70,-340,110>
  slot BackToGameSlot
  {
    //if ( IsDialog(false))
      //{
     // Owner.DismissDialog( this, null, null, null, null, null, false ); 
      //Owner.DismissDialog( Application::Menu, null, null, null, null, null, false );


    //  Owner.DismissDialog( this, null, null, null, null, null, false );
            var slot sl=this.CloseMenu;
          signal sl;    
        Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Game
  {
    preset StackingPriority = 8;
    preset Bounds = <329,216,471,248>;
    preset Visible = false;
    preset OnPress = BackToGameSlot;
    preset Label = "Back to the game";
    preset Appearance = ButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton GameRoom
  {
    preset StackingPriority = 9;
    preset Bounds = <329,256,471,310>;
    preset Visible = false;
    preset OnPress = BackToGameRoom;
    preset Label = "Back to the game room";
    preset Appearance = ButtonConfig;
  }

  $rect <-540,120,-340,160>
  slot BackToGameRoom
  {
    //if ( IsDialog(false))
    //  {
     Owner.DismissDialog( this, null, null, null, null, null, false ); 
    //  Owner.DismissDialog( Application::Menu, null, null, null, null, null, false );
    //  }
    //GetRoot().DismissDialog( this, null, null, null, null, null, false );
    GetRoot().SwitchToDialog(new Application::GameRoom, null, null, null, null, null, null, null, null, null, false );


  }

  $rect <-260,120,-80,160>
  inherited method Init()
  {
    ButtonsTimer.Enabled=true;

  }

  $rect <20,20,160,60>
  inherited object Frame
  {
    preset Bounds = <154,-1,647,486>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilter
  {
    preset Bounds = <311,127,486,340>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilterBackground
  {
    preset Bounds = <-2,-100,799,585>;
  }

  // Functionality buttons
  note group FunctionalityButtonsNote
  {
    attr Bounds = <-590,10,-290,180>;
  }

  // Effects
  note group EffectsNote
  {
    attr Bounds = <-590,190,-20,490>;
  }

  $rect <-560,260,-320,300>
  object Core::Timer ButtonsTimer
  {
    preset OnTrigger = ShowButtons;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-280,220,-50,260>
  slot ShowButtons
  {
    FilterEffect.Enabled=true;
     
                    
    //Game.Visible=true; 
    Music.Visible=true;
    SecondPulseColorTimer.Enabled=true;


  }

  $rect <-560,310,-320,350>
  object Core::Timer SecondPulseColorTimer
  {
    preset OnTrigger = SecondPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-280,360,-50,400>
  slot StopPulseColor
  {
    FilterEffect.Outlet=null;
  }

  $rect <-280,313,-50,353>
  slot ThirdPulseColor
  {
    GameRoom.Visible=true;

    StopPulseColorTimer.Enabled=true;
  }

  $rect <-560,400,-320,440>
  object Core::Timer StopPulseColorTimer
  {
    preset OnTrigger = StopPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-540,440,-340,480>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = null;
    preset Bounces = 4;
    preset Oscillations = 1;
    preset Timing = Effects::Timing.Circle_Out;
    preset Value2 = #000000FF;
    preset Value1 = Application::VibrantOrange;
    preset Outlet = ^BlackFilter.TintColor;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Music
  {
    preset StackingPriority = 9;
    preset Bounds = <329,178,471,216>;
    preset Visible = false;
    preset OnPress = MusicSLot;
    preset Label = "Play/Pause Music";
    preset Appearance = ButtonConfig;
  }

  $rect <-270,70,-70,110>
  slot MusicSLot
  {
    //if(Application::GuessTheWordMenu.MusicState==true)
    //{
    //$if (!$prototyper)
    //native{pauseMusic();}
    //$endif
    //Application::GuessTheWordMenu.MusicState=false; 
    //}
    //else
    //{
    //$if (!$prototyper)
    //native{playMusic();}
    //$endif 
    //Application::GuessTheWordMenu.MusicState=true;
    //}

  }

  $rect <-270,10,-70,50>
  var bool MusicState = true;

  $rect <-800,40,-600,80>
  var int32 Variable = 0;

  $rect <-560,354,-320,394>
  object Core::Timer ThirdPulseColorTimer
  {
    preset OnTrigger = ThirdPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-280,270,-50,310>
  slot SecondPulseColor
  {
    //GameRoom.Visible=true;
     Game.Visible=true; 
    ThirdPulseColorTimer.Enabled=true;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Frame
  $member BlackFilter
  $member BlackFilterBackground
  $member ButtonConfig
  $member BackToGameSlot
  $member Game
  $member GameRoom
  $member BackToGameRoom
  $member FunctionalityButtonsNote
  $member EffectsNote
  $member ButtonsTimer
  $member ShowButtons
  $member SecondPulseColorTimer
  $member StopPulseColor
  $member ThirdPulseColor
  $member StopPulseColorTimer
  $member FilterEffect
  $member Music
  $member MusicSLot
  $member MusicState
  $member Variable
  $member ThirdPulseColorTimer
  $member SecondPulseColor
}

$rect <1950,100,2150,140>
$output false
resource Resources::Bitmap MenuFrame
{
  attr bitmapfile FileName = .\menu_frame.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1950,150,2150,190>
$output false
resource Resources::Bitmap MenuBackground
{
  attr bitmapfile FileName = .\menu_background.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <630,1170,840,1210>
$output false
const color DarkOrange = #C67528FF;

// Colors
note group Colors
{
  attr Bounds = <610,1130,1370,1280>;
}

$rect <630,1220,840,1260>
$output false
const color VibrantOrange = #F3A52BFF;

$rect <860,1220,1070,1260>
$output false
const color LightOrange = #FFD10DFF;

$rect <860,1170,1070,1210>
$output false
const color Black = #000000FF;

$rect <1950,200,2150,240>
$output false
resource Resources::Bitmap open_menu
{
  attr bitmapfile FileName = .\open_icon.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// Menu images
note group MenuImages
{
  attr Bounds = <1900,50,2200,330>;
}

$rect <1950,250,2150,290>
$output false
resource Resources::Bitmap close_icon
{
  attr bitmapfile FileName = .\close_icon.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <1420,1130,1660,1170>
$output false
resource Resources::Font WordGuessingGameSmallFont
{
  attr fontname FontName = Constantia;
  attr fontheight Height = 17;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <690,1300,890,1340>
$output false
autoobject Core::KeyPressHandler EnterKeyHandler
{
  preset OnPress = null;
  preset Filter = Core::KeyCode.Enter;
}

$rect <1080,1170,1290,1210>
$output false
const color SandColor = #CCC0AFFF;

$rect <1760,1110,1960,1150>
$output false
class GameRoom : Core::Group
{
  $rect <-970,20,-770,60>
  inherited property Bounds = <0,0,800,480>;

  $rect <-970,180,-770,220>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-970,140,-770,180>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-590,300,-410,340>
  inherited method Init()
  {
  }

  $rect <-610,405,-370,445>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <-290,65,-60,105>
  slot OpenGuessingWordGame
  {
    //if ( IsDialog(false))
     //Owner.DismissDialog( this, null, null, null, null, null, false );
    //                     trace "Actual dialog1g", Owner;
    if ( IsActiveDialog( true ))
    {

      //GetRoot().PresentDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
      GetRoot().SwitchToDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //      trace "Actual dialog2g", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;

  }

  // Starting games
  note group StartingGames
  {
    attr Bounds = <-330,15,-30,225>;
  }

  // Effects handling
  note group Effects
  {
    attr Bounds = <-330,255,-30,455>;
  }

  // Timers for the effects
  note group Timers
  {
    attr Bounds = <-650,15,-350,215>;
  }

  $rect <-600,55,-400,95>
  object Core::Timer TimerGuessingGame
  {
    preset OnTrigger = OpenGuessingWordGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-300,305,-50,345>
  slot OnPressGuessingWordGame
  {
    WordGuessingButton.Icon=Application::OnPressWordGuessingLogo;


    TimerGuessingGame.Enabled=true;


  }

  $rect <-290,115,-60,155>
  slot OpenMemoryGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //  trace "Actual dialog1m", Owner;

    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //                       trace "Actual dialog2m", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,355,-50,395>
  slot OnPressMemoryGame
  {
    MemoryGameButton.Icon=Application::OnPressMemoryGameLogo;


    TimerMemoryGame.Enabled=true;


  }

  $rect <-600,105,-400,145>
  object Core::Timer TimerMemoryGame
  {
    preset OnTrigger = OpenMemoryGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-600,235,-400,275>
  slot DisableButtons
  {
    WordGuessingButton.Enabled=false;
    WordGuessingButton.Visible=false;
    MemoryGameButton.Enabled=false;
    MemoryGameButton.Visible=false;
    TilesPuzzleGameButton.Enabled=false;
    TilesPuzzleGameButton.Visible=false;
    Arrow.Enabled=false;
    Arrow.Visible=false;
    Sound.Enabled=false;
    Sound.Visible=false;

  }

  $rect <-600,155,-400,195>
  object Core::Timer TimeTilesPuzzleGame
  {
    preset OnTrigger = OpenTilesPuzzleGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-290,165,-60,205>
  slot OpenTilesPuzzleGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //      trace "Actual dialog1t", Owner;
    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null,null, false );
    //  trace "Actual dialog2t", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,405,-50,445>
  slot OnPressTilesPuzzleGame
  {
    TilesPuzzleGameButton.Icon=Application::OnPressTilesPuzzleLogo;


    TimeTilesPuzzleGame.Enabled=true;


  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Application::BackgroudGamingRoom;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton WordGuessingButton
  {
    preset Bounds = <157,172,289,305>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressGuessingWordGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::WordGuessingLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MemoryGameButton
  {
    preset Bounds = <324,169,456,302>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressMemoryGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::MemoryGameLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TilesPuzzleGameButton
  {
    preset Bounds = <486,169,633,302>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressTilesPuzzleGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::TilesPuzzleLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Arrow
  {
    preset Bounds = <636,523,730,574>;
    preset Icon = Application::Arrow;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Sound
  {
    preset Bounds = <46,47,120,115>;
    preset OnPress = MusicSLot;
    preset Icon = Application::sound_on;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <-280,480,-80,520>
  slot MusicSLot
  {
    ////if(Application::GuessTheWordMenu.MusicState==true)
    ////{
    ////$if (!$prototyper)
    ////native{pauseMusic();}
    ////$endif
    ////Application::GuessTheWordMenu.MusicState=false; 
    ////}
    ////else
    ////{
    ////$if (!$prototyper)
    ////native{playMusic();}
    ////$endif 
    ////Application::GuessTheWordMenu.MusicState=true;
    ////}
    //var bool musicPlaying=true;
    // $if (!$prototyper)
    //native{isAudioPlaying(musicPlaying);}
    //$endif
    //
    //if(musicPlaying==true)
    //{
    //$if (!$prototyper)
    //native{pauseMusic();}
    //$endif
    //musicPlaying=false; 
    //}
    //else
    //{
    //$if (!$prototyper)
    //native{playMusic();}
    //$endif 
    //musicPlaying=true;
    //}
    //// $endif 
    //
    //


  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member TransparentButton
  $member OpenGuessingWordGame
  $member StartingGames
  $member Effects
  $member Timers
  $member TimerGuessingGame
  $member OnPressGuessingWordGame
  $member OpenMemoryGame
  $member OnPressMemoryGame
  $member TimerMemoryGame
  $member DisableButtons
  $member TimeTilesPuzzleGame
  $member OpenTilesPuzzleGame
  $member OnPressTilesPuzzleGame
  $member Image
  $member WordGuessingButton
  $member MemoryGameButton
  $member TilesPuzzleGameButton
  $member Arrow
  $member Sound
  $member MusicSLot
}

$rect <1240,830,1440,870>
$output false
resource Resources::Bitmap sound_on
{
  attr bitmapfile FileName = .\sound_on.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1460,830,1660,870>
$output false
resource Resources::Bitmap sound_off
{
  attr bitmapfile FileName = .\sound_off.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}
