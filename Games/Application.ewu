$version 13.04

// This is the root component of the entire GUI application.
$rect <1766,990,1966,1030>
$output false
class Application : Core::Root
{
  $rect <-600,295,-400,335>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Application::BackgroudGamingRoom;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton WordGuessingButton
  {
    preset Bounds = <188,683,320,816>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressGuessingWordGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::WordGuessingLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <-610,405,-370,445>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <-290,65,-60,105>
  slot OpenGuessingWordGame
  {
    //if ( IsDialog(false))
     //Owner.DismissDialog( this, null, null, null, null, null, false );
    //                     trace "Actual dialog1g", Owner;
    if ( IsActiveDialog( true ))
    {

      //GetRoot().PresentDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
      GetRoot().SwitchToDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //      trace "Actual dialog2g", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;

  }

  // Starting games
  note group StartingGames
  {
    attr Bounds = <-330,15,-30,225>;
  }

  // Effects handling
  note group Effects
  {
    attr Bounds = <-330,255,-30,455>;
  }

  // Timers for the effects
  note group Timers
  {
    attr Bounds = <-650,15,-350,215>;
  }

  $rect <-600,55,-400,95>
  object Core::Timer TimerGuessingGame
  {
    preset OnTrigger = OpenGuessingWordGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-300,305,-50,345>
  slot OnPressGuessingWordGame
  {
    WordGuessingButton.Icon=Application::OnPressWordGuessingLogo;


    TimerGuessingGame.Enabled=true;


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MemoryGameButton
  {
    preset Bounds = <355,680,487,813>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressMemoryGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::MemoryGameLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <-290,115,-60,155>
  slot OpenMemoryGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //  trace "Actual dialog1m", Owner;

    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //                       trace "Actual dialog2m", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,355,-50,395>
  slot OnPressMemoryGame
  {
    MemoryGameButton.Icon=Application::OnPressMemoryGameLogo;


    TimerMemoryGame.Enabled=true;


  }

  $rect <-600,105,-400,145>
  object Core::Timer TimerMemoryGame
  {
    preset OnTrigger = OpenMemoryGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-600,235,-400,275>
  slot DisableButtons
  {
    WordGuessingButton.Enabled=false;
    WordGuessingButton.Visible=false;
    MemoryGameButton.Enabled=false;
    MemoryGameButton.Visible=false;
    TilesPuzzleGameButton.Enabled=false;
    TilesPuzzleGameButton.Visible=false;
    Arrow.Enabled=false;
    Arrow.Visible=false;
    Sound.Enabled=false;
    Sound.Visible=false;

  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TilesPuzzleGameButton
  {
    preset Bounds = <517,680,664,813>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressTilesPuzzleGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::TilesPuzzleLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <-600,155,-400,195>
  object Core::Timer TimeTilesPuzzleGame
  {
    preset OnTrigger = OpenTilesPuzzleGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-290,165,-60,205>
  slot OpenTilesPuzzleGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //      trace "Actual dialog1t", Owner;
    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null,null, false );
    //  trace "Actual dialog2t", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,405,-50,445>
  slot OnPressTilesPuzzleGame
  {
    TilesPuzzleGameButton.Icon=Application::OnPressTilesPuzzleLogo;


    TimeTilesPuzzleGame.Enabled=true;


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Arrow
  {
    preset Bounds = <818,340,912,391>;
    preset Icon = Application::Arrow;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <-580,360,-400,395>
  inherited method Init()
  {
    if(MusicPlay==true)
    {
    $if (!$prototyper)
    native{playMusic();}
    $endif
    MusicPlay=false;
    }
    //if ( IsActiveDialog( true ))
    //{
    //
    //  //GetRoot().PresentDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
    //  //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
    //  GetRoot().SwitchToDialog( new Application::GameRoom,null,null, null, null, null, null, null, null, null, false );
    ////      trace "Actual dialog2g", Owner;
    //}
    GetRoot().SwitchToDialog( new Application::GameRoom, null, null, null, null, null, null, null, null, null, false );



  }

  $rect <-590,460,-390,500>
  var bool MusicPlay = true;

  $rect <-280,480,-80,520>
  slot MusicSLot
  {
    $if (!$prototyper)
    native{isAudioPlaying();}
    $endif 


  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Sound
  {
    preset Bounds = <66,553,135,605>;
    preset OnPress = MusicSLot;
    preset Icon = Application::sound_off;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member Image
  $member WordGuessingButton
  $member TransparentButton
  $member OpenGuessingWordGame
  $member StartingGames
  $member Effects
  $member Timers
  $member TimerGuessingGame
  $member OnPressGuessingWordGame
  $member MemoryGameButton
  $member OpenMemoryGame
  $member OnPressMemoryGame
  $member TimerMemoryGame
  $member DisableButtons
  $member TilesPuzzleGameButton
  $member TimeTilesPuzzleGame
  $member OpenTilesPuzzleGame
  $member OnPressTilesPuzzleGame
  $member Arrow
  $member MusicPlay
  $member MusicSLot
  $member Sound
}

$rect <1420,980,1660,1020>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 38;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <740,780,980,820>
$output false
resource Resources::Bitmap BackgroudGamingRoom
{
  attr bitmapfile FileName = .\background_entry_room.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Images
note group Note
{
  attr Bounds = <690,-20,2310,910>;
}

$rect <740,460,980,500>
$output false
resource Resources::Bitmap WordGuessingLogo
{
  attr bitmapfile FileName = .\button_guess_words_game2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Classes
note group Note1
{
  attr Bounds = <1730,940,2220,1180>;
}

$rect <1766,1040,1966,1080>
$output false
class GuessTheWord : Core::Group
{
  $rect <-510,510,-310,550>
  inherited property Bounds = <0,0,800,496>;

  $rect <-1240,920,-1040,960>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-1240,880,-1040,920>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset StackingPriority = 10;
    preset Bounds = <177,42,263,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset StackingPriority = 10;
    preset Bounds = <293,42,379,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset StackingPriority = 10;
    preset Bounds = <413,42,499,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset StackingPriority = 10;
    preset Bounds = <534,42,620,118>;
    preset Bitmap = Application::PlaceholderGuessingGame;
  }

  $rect <20,20,160,60>
  object Views::Text FirstLetter
  {
    preset StackingPriority = 10;
    preset Bounds = <185,49,257,112>;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object Views::Text SecondLetter
  {
    preset StackingPriority = 10;
    preset Bounds = <300,49,372,112>;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object Views::Text ThirdLetter
  {
    preset StackingPriority = 10;
    preset Bounds = <420,49,492,112>;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object Views::Text ForthLetter
  {
    preset StackingPriority = 10;
    preset Bounds = <541,49,613,112>;
    preset OnUpdate = null;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton q
  {
    preset StackingPriority = 10;
    preset Bounds = <84,189,131,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::q;
    preset Label = "Q";
    preset Appearance = TransparentButton;
  }

  $rect <-1031,73,-791,113>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <20,20,160,60>
  object WidgetSet::PushButton m
  {
    preset StackingPriority = 10;
    preset Bounds = <521,327,569,382>;
    preset OnPress = PressLetter;
    preset Icon = Application::m;
    preset Label = "M";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton w
  {
    preset StackingPriority = 10;
    preset Bounds = <147,190,202,245>;
    preset OnPress = PressLetter;
    preset Icon = Application::w;
    preset Label = "W";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton e
  {
    preset StackingPriority = 10;
    preset Bounds = <212,190,265,248>;
    preset OnPress = PressLetter;
    preset Icon = Application::e;
    preset Label = "E";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton r
  {
    preset StackingPriority = 10;
    preset Bounds = <280,187,328,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::r;
    preset Label = "R";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton t
  {
    preset StackingPriority = 10;
    preset Bounds = <341,187,389,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::t;
    preset Label = "T";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton y
  {
    preset StackingPriority = 10;
    preset Bounds = <396,187,444,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::y;
    preset Label = "Y";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton u
  {
    preset StackingPriority = 10;
    preset Bounds = <461,188,509,243>;
    preset OnPress = PressLetter;
    preset Icon = Application::u;
    preset Label = "U";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton i
  {
    preset StackingPriority = 10;
    preset Bounds = <527,187,575,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::i;
    preset Label = "I";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton o
  {
    preset StackingPriority = 10;
    preset Bounds = <594,187,642,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::o;
    preset Label = "O";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton p
  {
    preset StackingPriority = 10;
    preset Bounds = <660,187,708,242>;
    preset OnPress = PressLetter;
    preset Icon = Application::p;
    preset Label = "P";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton A
  {
    preset StackingPriority = 9;
    preset Bounds = <98,243,146,325>;
    preset OnPress = PressLetter;
    preset Icon = Application::a;
    preset Label = "A";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton s
  {
    preset StackingPriority = 10;
    preset Bounds = <146,258,194,319>;
    preset OnPress = PressLetter;
    preset Icon = Application::s;
    preset Label = "S";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton d
  {
    preset StackingPriority = 10;
    preset Bounds = <212,260,260,315>;
    preset OnPress = PressLetter;
    preset Icon = Application::d;
    preset Label = "D";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton f
  {
    preset StackingPriority = 10;
    preset Bounds = <280,257,328,312>;
    preset OnPress = PressLetter;
    preset Icon = Application::f;
    preset Label = "F";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton g
  {
    preset StackingPriority = 10;
    preset Bounds = <341,254,389,312>;
    preset OnPress = PressLetter;
    preset Icon = Application::g;
    preset Label = "G";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton h
  {
    preset StackingPriority = 10;
    preset Bounds = <396,256,444,311>;
    preset OnPress = PressLetter;
    preset Icon = Application::h;
    preset Label = "H";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton j
  {
    preset StackingPriority = 10;
    preset Bounds = <461,261,509,316>;
    preset OnPress = PressLetter;
    preset Icon = Application::j;
    preset Label = "J";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton k
  {
    preset StackingPriority = 10;
    preset Bounds = <523,257,571,312>;
    preset OnPress = PressLetter;
    preset Icon = Application::k;
    preset Label = "K";
    preset Appearance = TransparentButton;
  }

  $rect <-670,450,-490,490>
  inherited method Init()
  {
    //Owner.PresentDialog( new Application::GuessTheWord, null, null, null, null, null, null, null, null, false );
    var int32 wordChoice=0;
    RandomChoice.String=string(wordChoice);

    //FirstLetter.String="";
    //SecondLetter.String="";
    //ThirdLetter.String="";
    //ForthLetter.String="";
    //LettersToUse.Visible=false;
    //GuessedLetters.String="";
    //GuessedLetters.Visible=false;
    //wordChoice = math_rand(0, 3);

  }

  // The disclaimer with the guessed letters that were not yet placed in the correct \
  // spot.
  $rect <20,20,160,60>
  object Views::Text GuessedLettersNote
  {
    preset StackingPriority = 15;
    preset Bounds = <68,408,588,472>;
    preset ColorTR = #FFCC2DFF;
    preset ColorTL = #FFDEB9FF;
    preset String = "Don't forget to use these letters:";
    preset Font = Application::WordGuessingGameFont;
    preset Visible = false;
  }

  // Game logic
  note group NoteGameLogic
  {
    attr Bounds = <-760,0,-150,500>;
  }

  $rect <20,20,160,60>
  object Views::Text GuessedText
  {
    preset StackingPriority = 12;
    preset Bounds = <217,166,549,343>;
    preset Padding = 0;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You won!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Visible = false;
  }

  $rect <-400,90,-200,130>
  slot GuessWord
  {
    var string firstOption="0";
    if(ForthLetter.String=="")
    {
        var slot sl = this.UnfilledSpacesSlot;
        signal sl;
    }          
    else
    {
    if(RandomChoice.String==firstOption)
    {
        var slot sl = this.GuessWordGame;
        signal sl;
        if(FirstLetter.Color!=#111111ff)
        FirstLetter.String="";
        
            if(SecondLetter.Color!=#111111ff)
        SecondLetter.String="";
        
            if(ThirdLetter.Color!=#111111ff)
        ThirdLetter.String="";

            if(ForthLetter.Color!=#111111ff)
        ForthLetter.String="";

    }
    //else if(wordChoice==1)
    //{
    //}
    //else if(wordChoice==2)
    //{
    //}
    //else if(wordChoice==3)
    //{
    //}
    }
  }

  $rect <20,20,160,60>
  object Views::Text RandomChoice
  {
    preset Bounds = <-287,514,-187,544>;
    preset String = "Text";
    preset Font = Resources::DefaultFont;
  }

  // Keyboard (for Enter see GuessWord)
  note group Keyboard
  {
    attr Bounds = <-700,40,-440,230>;
  }

  $rect <-400,140,-200,180>
  slot GuessWordGame
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

        if(FirstLetter.String=="G")
        {
           FirstLetter.Color=#111111ff;
           if(GuessedLetters.String!="")
           {
     
           var int32 poz=GuessedLetters.String.find( 'G', 0 );
           if(poz !=0)
             {
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
             if(GuessedLetters.String==" ")
             {
                GuessedLettersNote.Visible=false;
             }
           
           }
        }
        }
        else if(SecondLetter.String=="G" || ThirdLetter.String=="G" || ForthLetter.String=="G")
        {
                GuessedLettersNote.Visible=true;
                            if(GuessedLetters.String[0]!='G' && GuessedLetters.String[1]!='G' && GuessedLetters.String[2]!='G' && GuessedLetters.String[3]!='G')
                {
                GuessedLetters.String=GuessedLetters.String+" G";   
                }
                GuessedLetters.Visible=true;
        }

            if(SecondLetter.String=="A")
        {
           SecondLetter.Color=#111111ff;
            if(GuessedLetters.String!="")
           {
     
           var int32 poz=GuessedLetters.String.find( 'A', 0 );
           if(poz !=0)
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
           
           }
        }
            else if(FirstLetter.String=="A" || ThirdLetter.String=="A" || ForthLetter.String=="A")
        {
                GuessedLettersNote.Visible=true;
                if(GuessedLetters.String[0]!='A' && GuessedLetters.String[1]!='A' && GuessedLetters.String[2]!='A' && GuessedLetters.String[3]!='A')
                {
                GuessedLetters.String=GuessedLetters.String+" A";
                }
                GuessedLetters.Visible=true;
        }

            if(ThirdLetter.String=="M")
        {
           ThirdLetter.Color=#111111ff;
                  var int32 poz=GuessedLetters.String.find( 'M', 0 );
           if(poz !=0)
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
           
        }
        else if(SecondLetter.String=="M" || FirstLetter.String=="M" || ForthLetter.String=="M")
        {
                GuessedLettersNote.Visible=true;            
                if(GuessedLetters.String[0]!='M' && GuessedLetters.String[1]!='M' && GuessedLetters.String[2]!='M' && GuessedLetters.String[3]!='M')
                 {
                GuessedLetters.String=GuessedLetters.String+" M";   
                }
                GuessedLetters.Visible=true;
        }

            if(ForthLetter.String=="E")
        {
           ForthLetter.Color=#111111ff;
                  var int32 poz=GuessedLetters.String.find( 'E', 0 );
           if(poz !=0)
             GuessedLetters.String=GuessedLetters.String.remove( poz, 1 );
           
        }
            else if(SecondLetter.String=="E" || ThirdLetter.String=="E" || FirstLetter.String=="E")
        {
                GuessedLettersNote.Visible=true;
                if(GuessedLetters.String[0]!='E' && GuessedLetters.String[1]!='E' && GuessedLetters.String[2]!='E' && GuessedLetters.String[3]!='E')
                {
                GuessedLetters.String=GuessedLetters.String+" E";
                }
                GuessedLetters.Visible=true;
        }
        
        if(FirstLetter.String=="G" && SecondLetter.String=="A" && ThirdLetter.String=="M" && ForthLetter.String=="E")
    {
                 GuessedText.Visible=true;
                 //FilterKeyboard.Visible=true;
                 RevealFilterTimer.Enabled=true;
                 var slot sl=this.DisableKeyboard;
                 signal sl;
                 GuessedLettersNote.Visible=false;
    }
    else
    {
    var slot changeTrySlot=this.ChangeNumberTries;
    signal  changeTrySlot;
    }

  }

  // Word choices
  note group WordChoices
  {
    attr Bounds = <-430,40,-180,230>;
  }

  $rect <20,20,160,60>
  object Views::Text GuessedLetters
  {
    preset StackingPriority = 15;
    preset Bounds = <545,425,645,455>;
    preset ColorTR = #FFCC2DFF;
    preset ColorTL = #FFDEB9FF;
    preset String = "";
    preset Font = Application::WordGuessingGameFont;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton delete_key
  {
    preset StackingPriority = 10;
    preset Bounds = <585,257,735,307>;
    preset OnPress = PressDelete;
    preset Icon = Application::delete_key;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton enter
  {
    preset StackingPriority = 10;
    preset Bounds = <585,327,735,377>;
    preset OnPress = GuessWord;
    preset Icon = Application::enter;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton l
  {
    preset StackingPriority = 10;
    preset Bounds = <104,322,153,387>;
    preset OnPress = PressLetter;
    preset Icon = Application::l;
    preset Label = "L";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton z
  {
    preset StackingPriority = 10;
    preset Bounds = <153,329,201,379>;
    preset OnPress = PressLetter;
    preset Icon = Application::z;
    preset Label = "Z";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton x
  {
    preset StackingPriority = 10;
    preset Bounds = <217,327,265,377>;
    preset OnPress = PressLetter;
    preset Icon = Application::x;
    preset Label = "X";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton c
  {
    preset StackingPriority = 10;
    preset Bounds = <283,325,325,375>;
    preset OnPress = PressLetter;
    preset Icon = Application::c;
    preset Label = "C";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton v
  {
    preset StackingPriority = 10;
    preset Bounds = <341,327,381,377>;
    preset OnPress = PressLetter;
    preset Icon = Application::v;
    preset Label = "V";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton b
  {
    preset StackingPriority = 10;
    preset Bounds = <406,329,446,379>;
    preset OnPress = PressLetter;
    preset Icon = Application::b;
    preset Label = "B";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton n
  {
    preset StackingPriority = 10;
    preset Bounds = <461,332,510,382>;
    preset OnPress = PressLetter;
    preset Icon = Application::n;
    preset Label = "N";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object Views::Text UnfilledSpaces
  {
    preset StackingPriority = 12;
    preset Bounds = <107,36,735,126>;
    preset ColorTR = #FF7403FF;
    preset String = "Fill all the spaces";
    preset Font = Application::WordGuessingGameFont;
    preset Visible = false;
  }

  $rect <-690,390,-450,430>
  object Core::Timer TimerUnfilledSpaces
  {
    preset OnTrigger = DismissUnfilledSpacesWarning;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-690,340,-450,380>
  slot UnfilledSpacesSlot
  {
    UnfilledSpaces.Visible=true;
    UnfilledSpaces.Color=UnfilledSpacesGradient.Value;
    TimerUnfilledSpaces.Enabled=true;

  }

  $rect <-690,290,-450,330>
  slot DismissUnfilledSpacesWarning
  {
    UnfilledSpaces.Visible=false;

  }

  $rect <-670,170,-470,210>
  slot PressDelete
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(ForthLetter.String!="" && ForthLetter.Color!=#111111ff)
    {
    ForthLetter.String="";
    }
    else if(ThirdLetter.String!="" && ThirdLetter.Color!=#111111ff)
    {
    ThirdLetter.String="";
    }
    else if(SecondLetter.String!="" && SecondLetter.Color!=#111111ff)
    {
    SecondLetter.String="";
    }
    else if(FirstLetter.Color!=#111111ff) FirstLetter.String="";
  }

  $rect <-670,120,-470,160>
  slot PressLetter
  {
    sender; /* the method is called from the sender object */
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    var string toAddLetter;

    var WidgetSet::PushButton currentSender = (WidgetSet::PushButton )sender;

    if(currentSender==null)
    {
      if(LetterKeyHandler.CharCode>='A' && LetterKeyHandler.CharCode<='Z')
      {
        toAddLetter=string(LetterKeyHandler.CharCode);
      }
      else if (LetterKeyHandler.CharCode>='a' && LetterKeyHandler.CharCode<='z')
      {
          toAddLetter=string(LetterKeyHandler.CharCode-32);
      }
    }
    else
    {
       toAddLetter=currentSender.Label;
    }


    if(FirstLetter.String=="")
    {
    FirstLetter.String=toAddLetter;
    }
    else if(SecondLetter.String=="")
    {
    SecondLetter.String=toAddLetter;

    }
    else if(ThirdLetter.String=="")
    {
    ThirdLetter.String=toAddLetter;

    }
    else if(ForthLetter.String=="")
    {
    ForthLetter.String=toAddLetter;

    }


    FilterKeyboard.Visible=true;
    var slot sl = this.DisableKeyboard;
    signal sl;
    ButtonPressed.Enabled=true;



  }

  $rect <-1251,33,-1021,73>
  object Effects::ColorEffect UnfilledSpacesGradient
  {
    preset CycleDuration = 2000;
    preset Enabled = true;
  }

  // Special effects
  note group SpecialEffects
  {
    attr Bounds = <-1270,0,-770,730>;
  }

  $rect <-400,300,-200,340>
  object Core::Timer ButtonPressed
  {
    preset OnTrigger = PressButtonEffect;
    preset Period = 0;
    preset Begin = 300;
  }

  // Handling unfilled spaces
  note group HandlingUnfilledSpaces
  {
    attr Bounds = <-700,240,-440,440>;
  }

  // Handling unfilled spaces(also see keyboard above)
  note group HandlingButtonPressed
  {
    attr Bounds = <-430,240,-170,440>;
  }

  $rect <-400,350,-200,390>
  slot PressButtonEffect
  {
    FilterKeyboard.Visible=false;
    var slot sl = this.EnableKeyboard;
    signal sl;
  }

  $rect <20,20,160,60>
  object Views::FilterImage FilterKeyboard
  {
    preset StackingPriority = 11;
    preset Bounds = <74,180,735,393>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = Application::SandColor;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 180;
    preset Visible = false;
  }

  $rect <-1241,133,-1041,173>
  slot DisableKeyboard
  {
     k.Enabled=false;
                 A.Enabled=false;
                 b.Enabled=false;
                 c.Enabled=false;
                 e.Enabled=false;
                 f.Enabled=false;
                 g.Enabled=false;
                 h.Enabled=false;
                 i.Enabled=false;
                 j.Enabled=false;
                 l.Enabled=false;
                 m.Enabled=false;
                 n.Enabled=false;
                 o.Enabled=false;
                 p.Enabled=false;
                 q.Enabled=false;
                 r.Enabled=false;
                 d.Enabled=false;
                 t.Enabled=false;
                 w.Enabled=false;
                 x.Enabled=false;
                 y.Enabled=false;
                 z.Enabled=false;
                 s.Enabled=false;
                 u.Enabled=false;
                 v.Enabled=false;
                 enter.Enabled=false;
                 delete_key.Enabled=false;
  }

  $rect <-1241,83,-1041,123>
  slot EnableKeyboard
  {
     k.Enabled=true;
                 A.Enabled=true;
                 b.Enabled=true;
                 c.Enabled=true;
                 e.Enabled=true;
                 f.Enabled=true;
                 g.Enabled=true;
                 h.Enabled=true;
                 i.Enabled=true;
                 j.Enabled=true;
                 l.Enabled=true;
                 m.Enabled=true;
                 n.Enabled=true;
                 o.Enabled=true;
                 p.Enabled=true;
                 q.Enabled=true;
                 r.Enabled=true;
                 d.Enabled=true;
                 t.Enabled=true;
                 w.Enabled=true;
                 x.Enabled=true;
                 y.Enabled=true;
                 z.Enabled=true;
                 s.Enabled=true;
                 u.Enabled=true;
                 v.Enabled=true;
                 enter.Enabled=true;
                 delete_key.Enabled=true; 
  }

  // This autoobject provides the default customization for the 'push button' widget \
  // (WidgetSet::PushButton) in its medium size variant.
  $rect <-1031,123,-791,163>
  object WidgetSet::PushButtonConfig MenuButtonConfig
  {
    preset LabelColorActive = Application::LightOrange;
    preset LabelColorFocused = Application::LightOrange;
    preset LabelColorDisabled = Application::VibrantOrange;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::LightOrange;
    preset IconTintFocused = Application::VibrantOrange;
    preset IconTintDisabled = Application::DarkOrange;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Resources::FontLarge;
    preset WidgetMinSize = <34,34>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset StackingPriority = 10;
    preset Bounds = <-24,-5,98,89>;
    preset OnPress = OpenMenu;
    preset Icon = Application::open_menu;
    preset Label = "";
    preset Appearance = MenuButtonConfig;
  }

  $rect <-1241,490,-1041,530>
  slot OpenMenu
  {
    //BlackFilterBlackFilter.Visible=true;
    //GetRoot().PresentDialog( new Application::Menu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
    GetRoot().PresentDialog( new Application::GuessTheWordMenu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  $rect <-1010,276,-810,316>
  object Core::KeyPressHandler LetterKeyHandler
  {
    preset OnPress = PressLetter;
    preset Filter = Core::KeyCode.AlphaKeys;
  }

  $rect <-1010,226,-810,266>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = PressDelete;
    preset Filter = Core::KeyCode.Delete;
  }

  $rect <-1220,226,-1020,266>
  object Core::KeyPressHandler EnterKeyHandler
  {
    preset OnPress = GuessWord;
    preset Filter = Core::KeyCode.Enter;
  }

  $rect <-1220,276,-1020,316>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = PressDelete;
    preset Filter = Core::KeyCode.Backspace;
  }

  $rect <-1231,380,-1031,420>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = RevealFilter;
    preset Bounces = 3;
    preset Oscillations = 1;
    preset Value2 = #CCC0AF5F;
    preset Value1 = Application::SandColor;
    preset Outlet = ^FilterKeyboard.TintColor;
  }

  $rect <-1241,440,-1031,480>
  object Core::Timer RevealFilterTimer
  {
    preset OnTrigger = RevealFilter;
    preset Period = 0;
    preset Begin = 200;
  }

  $rect <-750,510,-520,550>
  slot RevealFilter
  {
    FilterEffect.Enabled=true;
    FilterKeyboard.Visible=true;
    ColorEffect.Enabled=true;
    DisableEffectTimer.Enabled=true;



  }

  $rect <-1011,440,-811,480>
  object Core::Timer DisableEffectTimer
  {
    preset OnTrigger = DisableEffect;
    preset Begin = 1500;
  }

  $rect <-1021,490,-811,530>
  slot DisableEffect
  {
    FilterEffect.Enabled=false;
    ColorEffect.Enabled=false;
  }

  $rect <-1011,380,-811,420>
  object Effects::ColorEffect ColorEffect
  {
    preset Value1 = Application::SandColor;
    preset Outlet = ^GuessedText.Color;
  }

  // Reveal win effect
  note group RevealWinEffectNote
  {
    attr Bounds = <-1251,340,-791,550>;
  }

  // Physical keyboard
  note group PhysicalKeyboardNote
  {
    attr Bounds = <-1250,190,-790,330>;
  }

  $rect <-1010,660,-810,700>
  slot ChangeNumberTries
  {
    sender; 
    Try--;
    if(Try==0)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;

    NumberTry.Bitmap=Application::Digit0;

    LostText.Visible=true;
    RevealFilterTimer.Enabled=true;
    var slot sl=this.DisableKeyboard;
    signal sl;
    GuessedLettersNote.Visible=false;
    GuessedLetters.Visible=false;

    }
    else
    if(Try==1)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;
      NumberTry.Bitmap=Application::Digit1;
    }
    else
    if(Try==2)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;
      NumberTry.Bitmap=Application::Digit2;
    }
    else
    if(Try==3)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;
      NumberTry.Bitmap=Application::Digit3;
    }
    else
    if(Try==4)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;
      NumberTry.Bitmap=Application::Digit4;
    }
    else
    if(Try==5)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;
      NumberTry.Bitmap=Application::Digit5;
    }
    else
    if(Try==6)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;
      NumberTry.Bitmap=Application::Digit6;
    }
    else
    if(Try==7)
    {
    ChangeNumberTryEffect.Enabled=true;
    StopNumberEffectTimer.Enabled=true;
      NumberTry.Bitmap=Application::Digit7;
    }
    else
    if(Try==8)
    {
    ChangeNumberTryEffect.Enabled=true;
      NumberTry.Bitmap=Application::Digit8;
    StopNumberEffectTimer.Enabled=true;
    }
  }

  $rect <20,20,160,60>
  object Views::Image NumberTry
  {
    preset StackingPriority = 10;
    preset Bounds = <715,17,765,67>;
    preset Bitmap = Application::Digit9;
    preset Opacity = 200;
  }

  $rect <-1230,-70,-1030,-30>
  var int32 Try = 9;

  $rect <-1250,660,-1030,700>
  object Effects::ColorEffect ChangeNumberTryEffect
  {
    preset Oscillations = 2;
    preset Outlet = ^NumberTry.Color;
  }

  $rect <-1250,610,-1030,650>
  object Core::Timer StopNumberEffectTimer
  {
    preset OnTrigger = StopNumberEffect;
    preset Period = 0;
    preset Begin = 550;
  }

  $rect <-1010,610,-810,650>
  slot StopNumberEffect
  {
    sender; 
    ChangeNumberTryEffect.Enabled=false;
  }

  $rect <20,20,160,60>
  object Views::Text LostText
  {
    preset StackingPriority = 12;
    preset Bounds = <37,166,775,343>;
    preset Padding = 0;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You lost! The word was GAME";
    preset Font = Application::WordGuessingGameFontWin;
    preset Visible = false;
  }

  // Number tries
  note group NumberTriesNote
  {
    attr Bounds = <-1260,560,-790,710>;
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Bounds = <-7,2,800,496>;
    preset Bitmap = Application::BackgroudGamingRoom;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Image
  $member Image1
  $member Image2
  $member Image3
  $member FirstLetter
  $member SecondLetter
  $member ThirdLetter
  $member ForthLetter
  $member q
  $member TransparentButton
  $member m
  $member w
  $member e
  $member r
  $member t
  $member y
  $member u
  $member i
  $member o
  $member p
  $member A
  $member s
  $member d
  $member f
  $member g
  $member h
  $member j
  $member k
  $member GuessedLettersNote
  $member NoteGameLogic
  $member GuessedText
  $member GuessWord
  $member RandomChoice
  $member Keyboard
  $member GuessWordGame
  $member WordChoices
  $member GuessedLetters
  $member delete_key
  $member enter
  $member l
  $member z
  $member x
  $member c
  $member v
  $member b
  $member n
  $member UnfilledSpaces
  $member TimerUnfilledSpaces
  $member UnfilledSpacesSlot
  $member DismissUnfilledSpacesWarning
  $member PressDelete
  $member PressLetter
  $member UnfilledSpacesGradient
  $member SpecialEffects
  $member ButtonPressed
  $member HandlingUnfilledSpaces
  $member HandlingButtonPressed
  $member PressButtonEffect
  $member FilterKeyboard
  $member DisableKeyboard
  $member EnableKeyboard
  $member MenuButtonConfig
  $member MenuButton
  $member OpenMenu
  $member LetterKeyHandler
  $member DeleteKeyHandler
  $member EnterKeyHandler
  $member BackspaceKeyHandler
  $member FilterEffect
  $member RevealFilterTimer
  $member RevealFilter
  $member DisableEffectTimer
  $member DisableEffect
  $member ColorEffect
  $member RevealWinEffectNote
  $member PhysicalKeyboardNote
  $member ChangeNumberTries
  $member NumberTry
  $member Try
  $member ChangeNumberTryEffect
  $member StopNumberEffectTimer
  $member StopNumberEffect
  $member LostText
  $member NumberTriesNote
  $member Background
}

$rect <740,830,980,870>
$output false
resource Resources::Bitmap PlaceholderGuessingGame
{
  attr bitmapfile FileName = .\placeholder_guessing_game2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Keyboard
note group Keyboard
{
  attr Bounds = <710,50,1860,390>;
}

$rect <790,90,990,130>
$output false
resource Resources::Bitmap q
{
  attr bitmapfile FileName = .\q.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,140,1850,180>
$output false
resource Resources::Bitmap m
{
  attr bitmapfile FileName = .\m.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,140,990,180>
$output false
resource Resources::Bitmap w
{
  attr bitmapfile FileName = .\w.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,190,990,230>
$output false
resource Resources::Bitmap e
{
  attr bitmapfile FileName = .\e.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,240,990,280>
$output false
resource Resources::Bitmap r
{
  attr bitmapfile FileName = .\r.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,290,990,330>
$output false
resource Resources::Bitmap t
{
  attr bitmapfile FileName = .\t.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <790,340,990,380>
$output false
resource Resources::Bitmap y
{
  attr bitmapfile FileName = .\y.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,90,1220,130>
$output false
resource Resources::Bitmap u
{
  attr bitmapfile FileName = .\u.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,140,1220,180>
$output false
resource Resources::Bitmap i
{
  attr bitmapfile FileName = .\i.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,190,1220,230>
$output false
resource Resources::Bitmap o
{
  attr bitmapfile FileName = .\o.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,240,1220,280>
$output false
resource Resources::Bitmap p
{
  attr bitmapfile FileName = .\p.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,290,1220,330>
$output false
resource Resources::Bitmap a
{
  attr bitmapfile FileName = .\a.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1020,340,1220,380>
$output false
resource Resources::Bitmap s
{
  attr bitmapfile FileName = .\s.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,90,1430,130>
$output false
resource Resources::Bitmap d
{
  attr bitmapfile FileName = .\d.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,140,1430,180>
$output false
resource Resources::Bitmap f
{
  attr bitmapfile FileName = .\f.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,190,1430,230>
$output false
resource Resources::Bitmap g
{
  attr bitmapfile FileName = .\g.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,240,1430,280>
$output false
resource Resources::Bitmap h
{
  attr bitmapfile FileName = .\h.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,290,1430,330>
$output false
resource Resources::Bitmap j
{
  attr bitmapfile FileName = .\j.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1230,340,1430,380>
$output false
resource Resources::Bitmap k
{
  attr bitmapfile FileName = .\k.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,90,1640,130>
$output false
resource Resources::Bitmap l
{
  attr bitmapfile FileName = .\l.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,140,1640,180>
$output false
resource Resources::Bitmap z
{
  attr bitmapfile FileName = .\z.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,190,1640,230>
$output false
resource Resources::Bitmap x
{
  attr bitmapfile FileName = .\x.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,240,1640,280>
$output false
resource Resources::Bitmap c
{
  attr bitmapfile FileName = .\c.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,290,1640,330>
$output false
resource Resources::Bitmap v
{
  attr bitmapfile FileName = .\v.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1440,340,1640,380>
$output false
resource Resources::Bitmap b
{
  attr bitmapfile FileName = .\b.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,90,1850,130>
$output false
resource Resources::Bitmap n
{
  attr bitmapfile FileName = .\n.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,190,1850,230>
$output false
resource Resources::Bitmap delete_key
{
  attr bitmapfile FileName = .\delete.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1650,240,1850,280>
$output false
resource Resources::Bitmap enter
{
  attr bitmapfile FileName = .\enter.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1420,1030,1660,1070>
$output false
resource Resources::Font WordGuessingGameFont
{
  attr fontname FontName = Constantia;
  attr fontheight Height = 32;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <740,510,980,550>
$output false
resource Resources::Bitmap OnPressWordGuessingLogo
{
  attr bitmapfile FileName = .\second_icon_guessinggame_for_pressed.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1420,1080,1660,1120>
$output false
resource Resources::Font WordGuessingGameFontWin
{
  attr fontname FontName = Constantia;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

// Fonts
note group Fonts
{
  attr Bounds = <1390,940,1690,1180>;
}

// Logos
note group Logos
{
  attr Bounds = <710,420,1010,760>;
}

$rect <740,560,980,600>
$output false
resource Resources::Bitmap MemoryGameLogo
{
  attr bitmapfile FileName = .\button_memory_game3.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <740,610,980,650>
$output false
resource Resources::Bitmap OnPressMemoryGameLogo
{
  attr bitmapfile FileName = .\icon_memory_game_after_pressed3.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1986,990,2186,1030>
$output false
class MemoryGame : Core::Group
{
  $rect <-518,540,-318,580>
  inherited property Bounds = <0,0,800,480>;

  $rect <-518,480,-318,520>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-518,440,-318,480>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-810,490,-570,530>
  object WidgetSet::PushButtonConfig PushButtonConfig;

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstLabyrinth
  {
    preset StackingPriority = 2;
    preset Bounds = <102,36,230,168>;
    preset OnPress = FirstLabyrinthPressed;
    preset ResignAfterHorizontalWipe = false;
    preset Icon = Application::Labyrinth;
    preset Label = "labyrinth1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstBlackLeaves
  {
    preset StackingPriority = 2;
    preset Bounds = <261,36,399,168>;
    preset OnPress = FirstBlackLeavesPressed;
    preset Icon = Application::BlackLeaves;
    preset Label = "blackleave1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstPendant
  {
    preset StackingPriority = 2;
    preset Bounds = <415,38,552,168>;
    preset OnPress = FirstPendantPressed;
    preset Icon = Application::Pandant;
    preset Label = "pandant1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstCoins
  {
    preset StackingPriority = 2;
    preset Bounds = <571,36,710,168>;
    preset OnPress = FirstCoinsPressed;
    preset Icon = Application::WhiteCoins;
    preset Label = "whitecoins1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondCoins
  {
    preset StackingPriority = 2;
    preset Bounds = <98,166,233,306>;
    preset OnPress = SecondCoinsPressed;
    preset Icon = Application::WhiteCoins;
    preset Label = "whitecoins2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstCup
  {
    preset StackingPriority = 2;
    preset Bounds = <260,168,398,308>;
    preset OnPress = FirstCupPressed;
    preset Icon = Application::cup;
    preset Label = "cup1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstGoldLeaves
  {
    preset StackingPriority = 2;
    preset Bounds = <418,168,554,308>;
    preset OnPress = FirstGoldLeavesPressed;
    preset Icon = Application::GoldLeaves;
    preset Label = "goldleaves1";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondCup
  {
    preset StackingPriority = 2;
    preset Bounds = <567,168,706,308>;
    preset OnPress = SecondCupPressed;
    preset Icon = Application::cup;
    preset Label = "cup2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondGoldLeaves
  {
    preset StackingPriority = 2;
    preset Bounds = <98,314,233,452>;
    preset OnPress = SecondGoldLeavesPressed;
    preset Icon = Application::GoldLeaves;
    preset Label = "goldleaves2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondPendant
  {
    preset StackingPriority = 2;
    preset Bounds = <260,314,398,452>;
    preset OnPress = SecondPendantPressed;
    preset Icon = Application::Pandant;
    preset Label = "pandant2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondLabyrinth
  {
    preset StackingPriority = 2;
    preset Bounds = <416,304,553,463>;
    preset OnPress = SecondLabyrinthPressed;
    preset Icon = Application::Labyrinth;
    preset Label = "labyrinth2";
    preset Appearance = PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondBlackLeaves
  {
    preset StackingPriority = 2;
    preset Bounds = <567,302,706,463>;
    preset OnPress = SecondBlackLeavesPressed;
    preset Icon = Application::BlackLeaves;
    preset Label = "blackleave2";
    preset Appearance = PushButtonConfig;
  }

  $rect <-1250,190,-1050,230>
  inherited method Init()
  {
    OpeningGameTimer.Enabled=true;
    LoseGameTimer.Enabled=true;
    UpdateTimer.Enabled=true;
    VerifyActivePlayingTimer.Enabled=true;


  }

  // Game logic
  note group GameLogic
  {
    attr Bounds = <-1350,-20,-70,430>;
  }

  // Designs and effects
  note group Design
  {
    attr Bounds = <-840,450,-540,650>;
  }

  // The logic for the first show of cards
  note group FirstShowOfCards
  {
    attr Bounds = <-1300,50,-1000,250>;
  }

  $rect <-1250,90,-1050,130>
  object Core::Timer OpeningGameTimer
  {
    preset OnTrigger = OpeningGame;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-1250,140,-1050,180>
  slot OpeningGame
  {
    FirstLabyrinth.Icon=Application::GoldPicture;
    SecondLabyrinth.Icon=Application::GoldPicture;
    FirstBlackLeaves.Icon=Application::GoldPicture;
    SecondBlackLeaves.Icon=Application::GoldPicture;
    FirstPendant.Icon=Application::GoldPicture;
    SecondPendant.Icon=Application::GoldPicture;
    FirstCoins.Icon=Application::GoldPicture;
    SecondCoins.Icon=Application::GoldPicture;
    FirstCup.Icon=Application::GoldPicture;
    SecondCup.Icon=Application::GoldPicture;
    FirstGoldLeaves.Icon=Application::GoldPicture;
    SecondGoldLeaves.Icon=Application::GoldPicture;

  }

  $rect <-940,90,-720,130>
  slot CountActiveCards
  {
    var int32 initialCount=0;

    if(FirstLabyrinth.Icon!=Application::GoldPicture)    initialCount++;

    if(SecondLabyrinth.Icon!=Application::GoldPicture)     initialCount++;
    if(FirstBlackLeaves.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondBlackLeaves.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstPendant.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondPendant.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstCoins.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondCoins.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstCup.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondCup.Icon!=Application::GoldPicture)    initialCount++;
    if(FirstGoldLeaves.Icon!=Application::GoldPicture)    initialCount++;
    if(SecondGoldLeaves.Icon!=Application::GoldPicture)    initialCount++;

    NumberDifferentPictures=initialCount;

  }

  // Cards management
  note group ManageCards
  {
    attr Bounds = <-970,50,-110,410>;
  }

  $rect <-940,180,-700,220>
  slot FirstLabyrinthPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstLabyrinth.Icon=Application::Labyrinth;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;


  }

  $rect <-940,230,-700,270>
  slot SecondLabyrinthPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondLabyrinth.Icon=Application::Labyrinth;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  // Revealing cards
  note group RevealingCards
  {
    attr Bounds = <-960,140,-140,390>;
  }

  $rect <-939,280,-700,320>
  slot FirstBlackLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstBlackLeaves.Icon=Application::BlackLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-940,330,-700,370>
  slot SecondBlackLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondBlackLeaves.Icon=Application::BlackLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-670,180,-430,220>
  slot FirstCupPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstCup.Icon=Application::cup;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-670,230,-430,270>
  slot SecondCupPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondCup.Icon=Application::cup;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-669,280,-430,320>
  slot FirstPendantPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstPendant.Icon=Application::Pandant;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-670,330,-430,370>
  slot SecondPendantPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondPendant.Icon=Application::Pandant;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-410,180,-170,220>
  slot FirstCoinsPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstCoins.Icon=Application::WhiteCoins;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-410,230,-170,270>
  slot SecondCoinsPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondCoins.Icon=Application::WhiteCoins;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-409,280,-170,320>
  slot FirstGoldLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    FirstGoldLeaves.Icon=Application::GoldLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    //var slot sl2=this.VerifyCards;
    //signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-410,330,-170,370>
  slot SecondGoldLeavesPressed
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    SecondGoldLeaves.Icon=Application::GoldLeaves;

    var slot sl=this.CountActiveCards;
    signal sl;

    var slot sl2=this.Schaffle;
    signal sl2;

    RevealCardTimer.Enabled=true;
  }

  $rect <-710,90,-510,130>
  slot VerifyCards
  {
    if(NumberDifferentPictures%2==0)
    {
    //if((FirstLabyrinth.Icon==Application::Labyrinth && SecondLabyrinth.Icon==Application::Labyrinth) || (SecondBlackLeaves.Icon==Application::BlackLeaves && FirstBlackLeaves.Icon==Application::BlackLeaves) || (FirstPendant.Icon==Application::Pandant && SecondPendant.Icon==Application::Pandant) || (FirstCoins.Icon==Application::WhiteCoins && SecondCoins.Icon==Application::WhiteCoins) || (FirstCup.Icon==Application::cup && SecondCup.Icon==Application::cup) || (FirstGoldLeaves.Icon==Application::GoldLeaves && SecondGoldLeaves.Icon==Application::GoldLeaves))
    //{
        if(FirstLabyrinth.Icon!=Application::Labyrinth || SecondLabyrinth.Icon!=Application::Labyrinth)
        {
        FirstLabyrinth.Icon=Application::GoldPicture;
        SecondLabyrinth.Icon=Application::GoldPicture;
        }

        if(SecondBlackLeaves.Icon!=Application::BlackLeaves || FirstBlackLeaves.Icon!=Application::BlackLeaves)
        {
        FirstBlackLeaves.Icon=Application::GoldPicture;
        SecondBlackLeaves.Icon=Application::GoldPicture;
        }

            if(FirstPendant.Icon!=Application::Pandant || SecondPendant.Icon!=Application::Pandant)
        {
        FirstPendant.Icon=Application::GoldPicture;
        SecondPendant.Icon=Application::GoldPicture;
        }

            if(FirstCup.Icon!=Application::cup || SecondCup.Icon!=Application::cup)
        {
        FirstCup.Icon=Application::GoldPicture;
        SecondCup.Icon=Application::GoldPicture;
        }

            if(FirstCoins.Icon!=Application::WhiteCoins || SecondCoins.Icon!=Application::WhiteCoins)
        {
        FirstCoins.Icon=Application::GoldPicture;
        SecondCoins.Icon=Application::GoldPicture;
        }

            if(FirstGoldLeaves.Icon!=Application::GoldLeaves || SecondGoldLeaves.Icon!=Application::GoldLeaves)
        {
        FirstGoldLeaves.Icon=Application::GoldPicture;
        SecondGoldLeaves.Icon=Application::GoldPicture;
        }

    //}   
    //else
    //{
    //
    //}

    NumberDifferentPictures=0;

    var slot sl=this.VerifyWin;
    signal sl;
    }
  }

  $rect <-520,600,-300,640>
  var int32 NumberDifferentPictures;

  $rect <-490,90,-290,130>
  object Core::Timer RevealCardTimer
  {
    preset OnTrigger = VerifyCards;
    preset Period = 0;
    preset Begin = 500;
  }

  $rect <-1260,270,-1060,310>
  slot VerifyWin
  {
    if(FirstLabyrinth.Icon==Application::Labyrinth && SecondLabyrinth.Icon==Application::Labyrinth && FirstCup.Icon==Application::cup && SecondCup.Icon==Application::cup && FirstPendant.Icon==Application::Pandant && SecondPendant.Icon==Application::Pandant && FirstBlackLeaves.Icon==Application::BlackLeaves && SecondBlackLeaves.Icon==Application::BlackLeaves && FirstCoins.Icon==Application::WhiteCoins && SecondCoins.Icon==Application::WhiteCoins && FirstGoldLeaves.Icon==Application::GoldLeaves && SecondGoldLeaves.Icon==Application::GoldLeaves)
       {

       RevealFilterWinTimer.Enabled=true;
       }

  }

  $rect <20,20,160,60>
  object Views::Text GuessedText
  {
    preset StackingPriority = 4;
    preset Bounds = <164,86,667,386>;
    preset Padding = 0;
    preset ColorBL = #FFFBF6FF;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You won!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Color = #FFF36AFF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::FilterImage FilterKeyboard
  {
    preset StackingPriority = 3;
    preset Bounds = <86,36,747,453>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = #CCC0AFFF;
    preset TintIntensity = 9.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 140;
    preset Visible = false;
  }

  $rect <-790,540,-590,580>
  slot Schaffle
  {
    //
    //  var int canvasWidth = 320;
    //  var int canvasHeight = 240;
    //  var int buttonWidth = 50;
    //  var int buttonHeight = 30;
    //
    //  // Generate random positions within the canvas bounds
    //  var int newX = Math::RandomInt32( 0, canvasWidth - buttonWidth );
    //  var int newY = Math::RandomInt32( 0, canvasHeight - buttonHeight );
    //
    //  // Set the new position using Core::Rect
    //  this.Bounds = Core::Rect( newX, newY, newX + buttonWidth, newY + buttonHeight );


  }

  $rect <-290,470,-90,510>
  property int32 Rotate;

  $rect <-290,510,-90,550>
  onset Rotate
  {
    // The value doesn't change - nothing to do.
    if ( pure Rotate == value )
      return;

    // Remember the property's new value.
    pure Rotate = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <-290,550,-90,590>
  onget Rotate
  {
    return pure Rotate;
  }

  $rect <-1260,330,-1060,370>
  slot OpenMenu
  {
    //BlackFilterBlackFilter.Visible=true;
    //GetRoot().PresentDialog( new Application::Menu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
    GetRoot().PresentDialog( new Application::MemoryGameMenu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  // This autoobject provides the default customization for the 'push button' widget \
  // (WidgetSet::PushButton) in its medium size variant.
  $rect <-820,590,-580,630>
  object WidgetSet::PushButtonConfig MenuButtonConfig
  {
    preset LabelColorActive = Application::LightOrange;
    preset LabelColorFocused = Application::LightOrange;
    preset LabelColorDisabled = Application::VibrantOrange;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::LightOrange;
    preset IconTintFocused = Application::VibrantOrange;
    preset IconTintDisabled = Application::DarkOrange;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Resources::FontLarge;
    preset WidgetMinSize = <34,34>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset StackingPriority = 2;
    preset Bounds = <-28,-21,86,69>;
    preset OnPress = OpenMenu;
    preset Icon = Application::open_menu;
    preset Label = "";
    preset Appearance = MenuButtonConfig;
  }

  $rect <-1320,490,-1120,530>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = null;
    preset Bounces = 3;
    preset Oscillations = 1;
    preset Value2 = #CCC0AF6E;
    preset Value1 = Application::SandColor;
    preset Outlet = ^FilterKeyboard.TintColor;
  }

  $rect <-1100,490,-910,530>
  object Core::Timer RevealFilterWinTimer
  {
    preset OnTrigger = RevealFilterWin;
    preset Period = 0;
    preset Begin = 200;
  }

  $rect <-1330,590,-1130,630>
  slot RevealFilterWin
  {
    FilterEffect.Enabled=true;
    FilterKeyboard.Visible=true;
    ColorEffect.Enabled=true;
    GuessedText.Visible=true;
    DisableEffectTimer.Enabled=true;



  }

  $rect <-1100,540,-910,580>
  object Core::Timer DisableEffectTimer
  {
    preset OnTrigger = DisableEffect;
    preset Begin = 1500;
  }

  $rect <-1110,590,-920,630>
  slot DisableEffect
  {
    FilterEffect.Enabled=false;
    ColorEffect.Enabled=false;
  }

  $rect <-1320,540,-1120,580>
  object Effects::ColorEffect ColorEffect
  {
    preset Value2 = #FFFFFFFF;
    preset Value1 = Application::SandColor;
    preset Outlet = ^GuessedText.Color;
  }

  // Reveal win or lose effect
  note group RevealWinEffectNote
  {
    attr Bounds = <-1340,450,-880,690>;
  }

  $rect <-330,0,-130,40>
  object Core::Timer LoseGameTimer
  {
    preset OnTrigger = LoseGame;
    preset Period = 0;
    preset Begin = 60000;
  }

  $rect <-550,0,-350,40>
  slot LoseGame
  {
    ColorEffect.Outlet=^LostText.Color;
    RevealFilterLoseTimer.Enabled=true;

    var slot sl=this.DisableCards;
    signal sl;

    var slot slotFilter=this.RevealFilterLose;
    signal slotFilter;
  }

  $rect <-1330,640,-1130,680>
  slot RevealFilterLose
  {
    ColorEffect.Outlet=^LostText.Color;
    FilterEffect.Enabled=true;
    FilterKeyboard.Visible=true;
    ColorEffect.Enabled=true;
    LostText.Visible=true;
    DisableEffectTimer.Enabled=true;
    GuessedText.Visible=false;

    FirstLabyrinth.Icon=Application::Labyrinth;
    SecondLabyrinth.Icon=Application::Labyrinth;
    FirstBlackLeaves.Icon=Application::BlackLeaves;
    SecondBlackLeaves.Icon=Application::BlackLeaves;
    FirstGoldLeaves.Icon=Application::GoldLeaves;
    SecondGoldLeaves.Icon=Application::GoldLeaves;
    FirstPendant.Icon=Application::Pandant;
    SecondPendant.Icon=Application::Pandant;
    FirstCoins.Icon=Application::WhiteCoins;
    SecondCoins.Icon=Application::WhiteCoins;
    FirstCup.Icon=Application::cup;
    SecondCup.Icon=Application::cup;











  }

  $rect <20,20,160,60>
  object Views::Text LostText
  {
    preset StackingPriority = 4;
    preset Bounds = <37,152,775,329>;
    preset Padding = 0;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You lost!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Visible = false;
  }

  $rect <-1260,380,-1060,420>
  slot DisableCards
  {
    sender; 

    FirstBlackLeaves.Enabled=false;
    FirstCoins.Enabled=false;
    FirstCup.Enabled=false;
    FirstGoldLeaves.Enabled=false;
    FirstLabyrinth.Enabled=false;
    FirstPendant.Enabled=false;
    SecondBlackLeaves.Enabled=false;
    SecondCoins.Enabled=false;
    SecondCup.Enabled=false;
    SecondGoldLeaves.Enabled=false;
    SecondLabyrinth.Enabled=false;
    SecondPendant.Enabled=false;


  }

  $rect <-1110,640,-910,680>
  object Core::Timer RevealFilterLoseTimer
  {
    preset OnTrigger = RevealFilterLose;
    preset Period = 0;
    preset Begin = 200;
  }

  $rect <20,20,160,60>
  object Views::Text TimeLeft
  {
    preset StackingPriority = 2;
    preset Bounds = <710,0,810,53>;
    preset ColorBR = #B38121FF;
    preset ColorTR = #FFC20CFF;
    preset String = "60";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <600,-70,800,-30>
  slot UpdateTimerSlot
  {
    Time--;
     if(Time>=0) 
     {
    TimeLeft.String=string(Time);
    }
  }

  $rect <390,-70,590,-30>
  object Core::Timer UpdateTimer
  {
    preset OnTrigger = UpdateTimerSlot;
    preset Period = 1000;
    preset Begin = 1000;
  }

  $rect <180,-70,380,-30>
  var int32 Time = 60;

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset StackingPriority = 1;
    preset Bounds = <4,-1,800,480>;
    preset Bitmap = Application::BackgroudGamingRoom;
  }

  $rect <10,540,210,580>
  object Core::Timer VerifyActivePlayingTimer
  {
    preset OnTrigger = VerifyActivePlaying;
    preset Period = 1;
    preset Begin = 1000;
  }

  $rect <240,540,440,580>
  slot VerifyActivePlaying
  {
    if( this.IsActiveDialog( true )==false)
    {
    UpdateTimer.Enabled=false;
    LoseGameTimer.Enabled=false;
    ActiveDialogBool=false;
    }

    if(ActiveDialogBool==false&&this.IsActiveDialog( true )==true)
    {

    UpdateTimer.Enabled=true;
    trace Time;
    LoseGameTimer.Period=Time*1000-20000;
    trace   LoseGameTimer.Period;
    LoseGameTimer.Enabled=true;

    ActiveDialogBool=true;
    }


  }

  $rect <-230,640,-30,680>
  var bool ActiveDialogBool = true;

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member PushButtonConfig
  $member FirstLabyrinth
  $member FirstBlackLeaves
  $member FirstPendant
  $member FirstCoins
  $member SecondCoins
  $member FirstCup
  $member FirstGoldLeaves
  $member SecondCup
  $member SecondGoldLeaves
  $member SecondPendant
  $member SecondLabyrinth
  $member SecondBlackLeaves
  $member GameLogic
  $member Design
  $member FirstShowOfCards
  $member OpeningGameTimer
  $member OpeningGame
  $member CountActiveCards
  $member ManageCards
  $member FirstLabyrinthPressed
  $member SecondLabyrinthPressed
  $member RevealingCards
  $member FirstBlackLeavesPressed
  $member SecondBlackLeavesPressed
  $member FirstCupPressed
  $member SecondCupPressed
  $member FirstPendantPressed
  $member SecondPendantPressed
  $member FirstCoinsPressed
  $member SecondCoinsPressed
  $member FirstGoldLeavesPressed
  $member SecondGoldLeavesPressed
  $member VerifyCards
  $member NumberDifferentPictures
  $member RevealCardTimer
  $member VerifyWin
  $member GuessedText
  $member FilterKeyboard
  $member Schaffle
  $member Rotate
  $member OnSetRotate
  $member OnGetRotate
  $member OpenMenu
  $member MenuButtonConfig
  $member MenuButton
  $member FilterEffect
  $member RevealFilterWinTimer
  $member RevealFilterWin
  $member DisableEffectTimer
  $member DisableEffect
  $member ColorEffect
  $member RevealWinEffectNote
  $member LoseGameTimer
  $member LoseGame
  $member RevealFilterLose
  $member LostText
  $member DisableCards
  $member RevealFilterLoseTimer
  $member TimeLeft
  $member UpdateTimerSlot
  $member UpdateTimer
  $member Time
  $member Background
  $member VerifyActivePlayingTimer
  $member VerifyActivePlaying
  $member ActiveDialogBool
}

$rect <1050,460,1250,500>
$output false
resource Resources::Bitmap cup
{
  attr bitmapfile FileName = .\cup6.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Images memory game
note group Note3
{
  attr Bounds = <1030,420,1330,810>;
}

$rect <1050,510,1250,550>
$output false
resource Resources::Bitmap WhiteCoins
{
  attr bitmapfile FileName = .\coins_background.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,560,1250,600>
$output false
resource Resources::Bitmap BlackLeaves
{
  attr bitmapfile FileName = .\golden_leaves_black_image1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,610,1250,650>
$output false
resource Resources::Bitmap GoldLeaves
{
  attr bitmapfile FileName = .\golden_leaves_gold_image1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,660,1250,700>
$output false
resource Resources::Bitmap Pandant
{
  attr bitmapfile FileName = .\pandant_picture2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,710,1250,750>
$output false
resource Resources::Bitmap Labyrinth
{
  attr bitmapfile FileName = .\labyrinth_picture1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1050,760,1250,800>
$output false
resource Resources::Bitmap GoldPicture
{
  attr bitmapfile FileName = .\blank_picture1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <740,660,980,700>
$output false
resource Resources::Bitmap TilesPuzzleLogo
{
  attr bitmapfile FileName = .\logo_tiles_puzzle1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <740,710,980,750>
$output false
resource Resources::Bitmap OnPressTilesPuzzleLogo
{
  attr bitmapfile FileName = .\on_press_tiles_puzzle_logo1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1986,1040,2186,1080>
$output false
class TilesPuzzle : Core::Group
{
  $rect <-960,740,-760,780>
  inherited property Bounds = <0,0,800,480>;

  $rect <-500,740,-300,780>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-720,740,-520,780>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,-17,800,480>;
    preset Bitmap = Application::Frame;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FirstTile
  {
    preset Bounds = <256,78,337,163>;
    preset OnPress = FirstTileMovement;
    preset Icon = Application::NinthTile;
    preset Label = "1";
    preset Appearance = TransparentButton;
  }

  $rect <-1670,750,-1430,790>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <20,20,160,60>
  object WidgetSet::PushButton FourthTile
  {
    preset Bounds = <499,80,580,160>;
    preset OnPress = FourthTileMovement;
    preset Icon = Application::ThirthTile;
    preset Label = "4";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ThirdTile
  {
    preset Bounds = <418,80,499,160>;
    preset OnPress = ThirdTileMovement;
    preset Icon = Application::EleventhTile;
    preset Label = "3";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SecondTile
  {
    preset Bounds = <337,78,418,160>;
    preset OnPress = SecondTileMovement;
    preset Icon = Application::FirstTile;
    preset Label = "2";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FifthTile
  {
    preset Bounds = <255,159,336,244>;
    preset OnPress = FifthTileMovement;
    preset Icon = Application::TenthTile;
    preset Label = "5";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton NinthTile
  {
    preset Bounds = <256,241,337,326>;
    preset OnRelease = null;
    preset OnPress = NinthTileMovement;
    preset Icon = Application::ThirteenTile;
    preset Label = "9";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ThirteenthTile
  {
    preset Bounds = <256,322,337,407>;
    preset OnPress = ThirteenthTileMovement;
    preset Icon = Application::ForteenthTile;
    preset Label = "13";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SixthTile
  {
    preset Bounds = <337,159,418,244>;
    preset OnPress = SixthTileMovement;
    preset Icon = Application::SecondTile;
    preset Label = "6";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SeventhTile
  {
    preset Bounds = <418,158,499,243>;
    preset OnPress = SeventhTileMovement;
    preset Icon = Application::SixthTile;
    preset Label = "7";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton EighthTile
  {
    preset Bounds = <500,158,581,243>;
    preset OnPress = EighthTileMovement;
    preset Icon = Application::ForthTile;
    preset Label = "8";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TenthTile
  {
    preset Bounds = <337,242,418,323>;
    preset OnPress = TenthTileMovement;
    preset Icon = Application::BackgroudGamingRoom;
    preset Label = "10";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton EleventhTile
  {
    preset Bounds = <419,241,500,326>;
    preset OnPress = EleventhTileMovement;
    preset Icon = Application::FifthTile;
    preset Label = "11";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TwelfthTile
  {
    preset Bounds = <500,240,581,325>;
    preset OnPress = TwelfthTileMovement;
    preset Icon = Application::SeventhTile;
    preset Label = "12";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FourteenthTile
  {
    preset Bounds = <338,321,419,406>;
    preset OnPress = FourteenthTileMovement;
    preset Icon = Application::FifteenthTile;
    preset Label = "14";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FifteenthTile
  {
    preset Bounds = <418,323,499,408>;
    preset OnPress = FifteenthTileMovement;
    preset Icon = Application::EighthTile;
    preset Label = "15";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SixteenthTile
  {
    preset Bounds = <500,322,581,407>;
    preset OnPress = SixteenthTileMovement;
    preset Icon = Application::TwelfthTile;
    preset Label = "16";
    preset Appearance = TransparentButton;
  }

  $rect <-930,110,-730,150>
  var int32 FirstPos = 9;

  $rect <-929,160,-729,200>
  var int32 SecondPos = 1;

  $rect <-930,260,-730,300>
  var int32 FourthPos = 3;

  $rect <-710,110,-510,150>
  var int32 FifthPos = 10;

  $rect <-710,160,-510,200>
  var int32 SixthPos = 2;

  $rect <-710,210,-510,250>
  var int32 SeventhPos = 6;

  $rect <-710,260,-510,300>
  var int32 EighthPos = 4;

  $rect <-490,110,-290,150>
  var int32 NinthPos = 13;

  $rect <-490,160,-290,200>
  var int32 TenthPos = 0;

  $rect <-490,210,-290,250>
  var int32 EleventhPos = 5;

  $rect <-490,260,-290,300>
  var int32 TwelfthPos = 7;

  $rect <-270,110,-70,150>
  var int32 ThirteenthPos = 14;

  $rect <-270,160,-70,200>
  var int32 FourteenthPos = 15;

  $rect <-270,210,-70,250>
  var int32 FifteenthPos = 8;

  $rect <-930,210,-730,250>
  var int32 ThirdPos = 11;

  // Tiles' positions
  note group TilesPositions
  {
    attr Bounds = <-970,50,-40,330>;
  }

  // Tiles' movement
  note group TilesMovement
  {
    attr Bounds = <-970,340,-40,640>;
  }

  $rect <-270,260,-70,300>
  var int32 SixteenthPos = 12;

  $rect <20,20,160,60>
  object Views::Text GuessedText
  {
    preset StackingPriority = 3;
    preset Bounds = <149,90,652,390>;
    preset Padding = 0;
    preset OnUpdate = null;
    preset ColorBL = #FFFBF6FF;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You won!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Color = #FFF36AFF;
    preset Visible = false;
  }

  $rect <-940,390,-740,430>
  slot FirstTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SecondPos==0)
    {
    SecondPos=FirstPos;
    FirstPos=0;
    SecondTile.Icon=FirstTile.Icon;
    FirstTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FifthPos==0)
    {
    FifthPos=FirstPos;
    FirstPos=0;
    FifthTile.Icon=FirstTile.Icon;
    FirstTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-940,440,-740,480>
  slot SecondTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FirstPos==0)
    {
    FirstPos=SecondPos;
    SecondPos=0;
    FirstTile.Icon=SecondTile.Icon;
    SecondTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SixthPos==0)
    {
    SixthPos=SecondPos;
    SecondPos=0;
    SixthTile.Icon=SecondTile.Icon;
    SecondTile.Icon=Application::BackgroudGamingRoom;
    }

    if(ThirdPos==0)
    {
    ThirdPos=SecondPos;
    SecondPos=0;
    ThirdTile.Icon=SecondTile.Icon;
    SecondTile.Icon=Application::BackgroudGamingRoom;
    }


    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-940,490,-740,530>
  slot ThirdTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SecondPos==0)
    {
    SecondPos=ThirdPos;
    ThirdPos=0;
    SecondTile.Icon=ThirdTile.Icon;
    ThirdTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=ThirdPos;
    ThirdPos=0;
    SeventhTile.Icon=ThirdTile.Icon;
    ThirdTile.Icon=Application::BackgroudGamingRoom;
    }


    if(FourthPos==0)
    {
    FourthPos=ThirdPos;
    ThirdPos=0;
    FourthTile.Icon=ThirdTile.Icon;
    ThirdTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-940,540,-740,580>
  slot FourthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(ThirdPos==0)
    {
    ThirdPos=FourthPos;
    FourthPos=0;
    ThirdTile.Icon=FourthTile.Icon;
    FourthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EighthPos==0)
    {
    EighthPos=FourthPos;
    FourthPos=0;
    EighthTile.Icon=FourthTile.Icon;
    FourthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,390,-520,430>
  slot FifthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FirstPos==0)
    {
    FirstPos=FifthPos;
    FifthPos=0;
    FirstTile.Icon=FifthTile.Icon;
    FifthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SixthPos==0)
    {
    SixthPos=FifthPos;
    FifthPos=0;
    SixthTile.Icon=FifthTile.Icon;
    FifthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(NinthPos==0)
    {
    NinthPos=FifthPos;
    FifthPos=0;
    NinthTile.Icon=FifthTile.Icon;
    FifthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,440,-520,480>
  slot SixthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SecondPos==0)
    {
    SecondPos=SixthPos;
    SixthPos=0;
    SecondTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FifthPos==0)
    {
    FifthPos=SixthPos;
    SixthPos=0;
    FifthTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=SixthPos;
    SixthPos=0;
    SeventhTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=SixthPos;
    SixthPos=0;
    TenthTile.Icon=SixthTile.Icon;
    SixthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,490,-520,530>
  slot SeventhTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(ThirdPos==0)
    {
    ThirdPos=SeventhPos;
    SeventhPos=0;
    ThirdTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SixthPos==0)
    {
    SixthPos=SeventhPos;
    SeventhPos=0;
    SixthTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EighthPos==0)
    {
    EighthPos=SeventhPos;
    SeventhPos=0;
    EighthTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EleventhPos==0)
    {
    EleventhPos=SeventhPos;
    SeventhPos=0;
    EleventhTile.Icon=SeventhTile.Icon;
    SeventhTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-720,540,-520,580>
  slot EighthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(TwelfthPos==0)
    {
    TwelfthPos=EighthPos;
    EighthPos=0;
    TwelfthTile.Icon=EighthTile.Icon;
    EighthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=EighthPos;
    EighthPos=0;
    SeventhTile.Icon=EighthTile.Icon;
    EighthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FourthPos==0)
    {
    FourthPos=EighthPos;
    EighthPos=0;
    FourthTile.Icon=EighthTile.Icon;
    EighthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,390,-300,430>
  slot NinthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifthPos==0)
    {
    FifthPos=NinthPos;
    NinthPos=0;
    FifthTile.Icon=NinthTile.Icon;
    NinthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=NinthPos;
    NinthPos=0;
    TenthTile.Icon=NinthTile.Icon;
    NinthTile.Icon=Application::BackgroudGamingRoom;

    }

    if(ThirteenthPos==0)
    {
    ThirteenthPos=NinthPos;
    NinthPos=0;
    ThirteenthTile.Icon=NinthTile.Icon;
    NinthTile.Icon=Application::BackgroudGamingRoom;
    }


    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,440,-300,480>
  slot TenthTileMovement
  {
    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SixthPos==0)
    {
    SixthPos=TenthPos;
    TenthPos=0;
    SixthTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(NinthPos==0)
    {
    NinthPos=TenthPos;
    TenthPos=0;
    NinthTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EleventhPos==0)
    {
    EleventhPos=TenthPos;
    TenthPos=0;
    EleventhTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FourteenthPos==0)
    {
    FourteenthPos=TenthPos;
    TenthPos=0;
    FourteenthTile.Icon=TenthTile.Icon;
    TenthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,490,-300,530>
  slot EleventhTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifteenthPos==0)
    {
    FifteenthPos=EleventhPos;
    EleventhPos=0;
    FifteenthTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;

    }

           //not tested yet
    if(TwelfthPos==0)
    {
    TwelfthPos=EleventhPos;
    EleventhPos=0;
    TwelfthTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=EleventhPos;
    EleventhPos=0;
    TenthTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;
    }

    if(SeventhPos==0)
    {
    SeventhPos=EleventhPos;
    EleventhPos=0;
    SeventhTile.Icon=EleventhTile.Icon;
    EleventhTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-500,540,-300,580>
  slot TwelfthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SixteenthPos==0)
    {
    SixteenthPos=TwelfthPos;
    TwelfthPos=0;
    SixteenthTile.Icon=TwelfthTile.Icon;
    TwelfthTile.Icon=Application::BackgroudGamingRoom;
    }

        //unverified
    if(EighthPos==0)
    {
    EighthPos=TwelfthPos;
    TwelfthPos=0;
    EighthTile.Icon=TwelfthTile.Icon;
    TwelfthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(EleventhPos==0)
    {
    EleventhPos=TwelfthPos;
    TwelfthPos=0;
    EleventhTile.Icon=TwelfthTile.Icon;
    TwelfthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,390,-70,430>
  slot ThirteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FourteenthPos==0)
    {
    FourteenthPos=ThirteenthPos;
    ThirteenthPos=0;
    FourteenthTile.Icon=ThirteenthTile.Icon;
    ThirteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(NinthPos==0)
    {
    NinthPos=ThirteenthPos;
    ThirteenthPos=0;
    NinthTile.Icon=ThirteenthTile.Icon;
    ThirteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,440,-70,480>
  slot FourteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifteenthPos==0)
    {
    FifteenthPos=FourteenthPos;
    FourteenthPos=0;
    FifteenthTile.Icon=FourteenthTile.Icon;
    FourteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TenthPos==0)
    {
    TenthPos=FourteenthPos;
    FourteenthPos=0;
    TenthTile.Icon=FourteenthTile.Icon;
    FourteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(ThirteenthPos==0)
    {
    ThirteenthPos=FourteenthPos;
    FourteenthPos=0;
    ThirteenthTile.Icon=FourteenthTile.Icon;
    FourteenthTile.Icon=Application::BackgroudGamingRoom;
    }



    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,490,-70,530>
  slot FifteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(SixteenthPos==0)
    {
    SixteenthPos=FifteenthPos;
    FifteenthPos=0;
    SixteenthTile.Icon=FifteenthTile.Icon;
    FifteenthTile.Icon=Application::BackgroudGamingRoom;

    }

    if(EleventhPos==0)
    {
    EleventhPos=FifteenthPos;
    FifteenthPos=0;
    EleventhTile.Icon=FifteenthTile.Icon;
    FifteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(FourteenthPos==0)
    {
    FourteenthPos=FifteenthPos;
    FifteenthPos=0;
    FourteenthTile.Icon=FifteenthTile.Icon;
    FifteenthTile.Icon=Application::BackgroudGamingRoom;
    }



    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-280,540,-70,580>
  slot SixteenthTileMovement
  {
    sender; /* the method is called from the sender object */

    $if (!$prototyper)
    native{pressKey();}
    $endif 

    if(FifteenthPos==0)
    {
    FifteenthPos=SixteenthPos;
    SixteenthPos=0;
    FifteenthTile.Icon=SixteenthTile.Icon;
    SixteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    if(TwelfthPos==0)
    {
    TwelfthPos=SixteenthPos;
    SixteenthPos=0;
    TwelfthTile.Icon=SixteenthTile.Icon;
    SixteenthTile.Icon=Application::BackgroudGamingRoom;
    }

    var slot sl=this.FindSolution;
    signal sl;
  }

  $rect <-950,660,-750,700>
  slot FindSolution
  {
    if(FirstPos==1 && SecondPos==2 && ThirdPos==3 && FourthPos==4 && FifthPos==5 && SixthPos==6 && SeventhPos==7 && EighthPos==8 && NinthPos==9 && TenthPos==10 && EleventhPos==11 && TwelfthPos==12 && ThirteenthPos==13 && FourteenthPos==14 && FifteenthPos==15 && SixteenthPos==0)
    {
    Guessed=true;
    RevealTilesTimer.Enabled=true;
    }


  }

  note arrow Note
  {
    attr Point1 = <-970,90>;
    attr Point2 = <-1030,110>;
  }

  // Game logic
  note group GameLogic
  {
    attr Bounds = <-990,10,-20,720>;
  }

  // The positions are used to identify the placement of the images at any given \
  // time. They do not move, the images on them change.
  note legend PositionsLegend2
  {
    attr Bounds = <-1330,100,-1030,300>;
  }

  // Tiles' movement
  note group TilesMovement1
  {
    attr Bounds = <-970,340,-40,640>;
  }

  // Tiles' positions
  note group TilesPositions1
  {
    attr Bounds = <-970,50,-40,330>;
  }

  // Effects
  note group Effects
  {
    attr Bounds = <-1720,330,-1020,800>;
  }

  $rect <-1670,430,-1440,470>
  slot RevealCompletedPicture
  {
    Solution.Visible=true;

    RevealGuessedTextTimer.Enabled=true;
    RevealFilterTimer.Enabled=true;

  }

  $rect <-1670,480,-1440,520>
  slot RevealAllTiles
  {
    if(Guessed==true)
    {
    SixteenthTile.Icon=Application::SixteenthTile;
    }
    RevealPictureTimer.Enabled=true;
  }

  // Reveal answer
  note group RevealAnswer
  {
    attr Bounds = <-1680,390,-1070,740>;
  }

  $rect <-1390,430,-1120,470>
  object Core::Timer RevealTilesTimer
  {
    preset OnTrigger = RevealAllTiles;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-1390,480,-1120,520>
  object Core::Timer RevealPictureTimer
  {
    preset OnTrigger = RevealCompletedPicture;
    preset Period = 0;
    preset Begin = 1500;
  }

  $rect <20,20,160,60>
  object Views::Image Solution
  {
    preset Bounds = <257,72,581,405>;
    preset Bitmap = Application::Medusa;
    preset Visible = false;
  }

  $rect <-1389,530,-1120,570>
  object Core::Timer RevealGuessedTextTimer
  {
    preset OnTrigger = RevealGuessedText;
    preset Period = 0;
    preset Begin = 1200;
  }

  $rect <-1670,530,-1440,570>
  slot RevealGuessedText
  {
    if(Guessed==true)
    GuessedText.Visible=true;
    else
    {
    LostText.Visible=true;
    }
    //RevealFilterTimer.Enabled=true;

  }

  $rect <20,20,160,60>
  object Views::FilterImage FilterKeyboard
  {
    preset Bounds = <250,75,581,409>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = #180E00FF;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 100;
    preset Visible = false;
  }

  $rect <-1460,690,-1260,730>
  object Effects::ColorEffect GuessedTextPulse
  {
    preset OnAnimate = FindSolution;
    preset Bounces = 6;
    preset TimingCustom2 = 0.0;
    preset TimingCustom1 = 0.0;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 6;
    preset Enabled = false;
    preset Value2 = #D2851BFF;
    preset Value1 = #F3FF00FF;
    preset Outlet = ^GuessedText.Color;
  }

  $rect <-1390,580,-1120,620>
  object Core::Timer RevealFilterTimer
  {
    preset OnTrigger = RevealFilter;
    preset Period = 0;
    preset Begin = 200;
  }

  $rect <-1670,580,-1440,620>
  slot RevealFilter
  {
    FilterEffect.Enabled=true;
    FilterKeyboard.Visible=true;
    DisableEffectTimer.Enabled=true;



  }

  $rect <-1670,690,-1470,730>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = RevealFilter;
    preset Bounces = 3;
    preset Oscillations = 1;
    preset Value2 = #000000FF;
    preset Value1 = #E8A0385D;
    preset Outlet = ^FilterKeyboard.TintColor;
  }

  $rect <-1670,630,-1440,670>
  slot DisableEffect
  {
    FilterEffect.Enabled=false;
  }

  $rect <-1390,630,-1120,670>
  object Core::Timer DisableEffectTimer
  {
    preset OnTrigger = DisableEffect;
    preset Begin = 1500;
  }

  $rect <-270,660,-70,700>
  slot OpenMenu
  {
    //BlackFilterBlackFilter.Visible=true;
    //Variable=Time;
    //GetRoot().PresentDialog( new Application::Menu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
    GetRoot().PresentDialog( new Application::TilesPuzzleMenu,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  // This autoobject provides the default customization for the 'push button' widget \
  // (WidgetSet::PushButton) in its medium size variant.
  $rect <-1410,750,-1170,790>
  object WidgetSet::PushButtonConfig MenuButtonConfig
  {
    preset LabelColorActive = Application::LightOrange;
    preset LabelColorFocused = Application::LightOrange;
    preset LabelColorDisabled = Application::VibrantOrange;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::LightOrange;
    preset IconTintFocused = Application::VibrantOrange;
    preset IconTintDisabled = Application::DarkOrange;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Resources::FontLarge;
    preset WidgetMinSize = <34,34>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset StackingPriority = 2;
    preset Bounds = <-39,-20,111,74>;
    preset OnPress = OpenMenu;
    preset Icon = Application::open_menu;
    preset Label = "";
    preset Appearance = MenuButtonConfig;
  }

  $rect <-270,740,-90,780>
  inherited method Init()
  {
     UpdateTimer.Enabled=true;
     LoseGameTimer.Enabled=true; 
     VerifyActivePlayingTimer.Enabled=true;
     
  }

  $rect <-1710,270,-1510,310>
  var bool Guessed = false;

  $rect <20,20,160,60>
  object Views::Text LostText
  {
    preset StackingPriority = 2;
    preset Bounds = <31,152,769,329>;
    preset Padding = 0;
    preset ColorBR = #D27129FF;
    preset ColorTR = #D27129FF;
    preset ColorTL = #070707FF;
    preset String = "You lost!";
    preset Font = Application::WordGuessingGameFontWin;
    preset Visible = false;
  }

  $rect <-690,660,-490,700>
  slot LostGame
  {
    sender; 
    RevealPictureTimer.Enabled=true;

    //var slot sl=this.RevealCompletedPicture;
    //signal sl;
  }

  $rect <-480,660,-280,700>
  object Core::Timer LoseGameTimer
  {
    preset OnTrigger = LostGame;
    preset Period = 0;
    preset Begin = 60000;
  }

  $rect <20,20,160,60>
  object Views::Text TimeLeft
  {
    preset Bounds = <702,0,802,53>;
    preset ColorBR = #B38121FF;
    preset ColorTR = #FFC20CFF;
    preset String = "60";
    preset Font = Application::WordGuessingGameFont;
  }

  $rect <600,-70,800,-30>
  slot UpdateTimerSlot
  {
    Time--;
     if(Time>=0) 
     {
    TimeLeft.String=string(Time);
    }
  }

  $rect <390,-70,590,-30>
  object Core::Timer UpdateTimer
  {
    preset OnTrigger = UpdateTimerSlot;
    preset Period = 1000;
    preset Begin = 1000;
  }

  $rect <180,-70,380,-30>
  var int32 Time = 60;

  $rect <-50,-70,150,-30>
  var int32 Variable;

  $rect <10,540,210,580>
  object Core::Timer VerifyActivePlayingTimer
  {
    preset OnTrigger = VerifyActivePlaying;
    preset Period = 1;
    preset Begin = 1;
  }

  $rect <240,540,440,580>
  slot VerifyActivePlaying
  {
    if( this.IsActiveDialog( true )==false)
    {
    UpdateTimer.Enabled=false;
    LoseGameTimer.Enabled=false;
    ActiveDialogBool=false;
    }

    if(ActiveDialogBool==false&&this.IsActiveDialog( true )==true)
    {
    UpdateTimer.Enabled=true;
    LoseGameTimer.Enabled=true;
    ActiveDialogBool=true;
    }


  }

  $rect <20,620,220,660>
  var bool ActiveDialogBool = true;

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Image
  $member FirstTile
  $member TransparentButton
  $member FourthTile
  $member ThirdTile
  $member SecondTile
  $member FifthTile
  $member NinthTile
  $member ThirteenthTile
  $member SixthTile
  $member SeventhTile
  $member EighthTile
  $member TenthTile
  $member EleventhTile
  $member TwelfthTile
  $member FourteenthTile
  $member FifteenthTile
  $member SixteenthTile
  $member FirstPos
  $member SecondPos
  $member FourthPos
  $member FifthPos
  $member SixthPos
  $member SeventhPos
  $member EighthPos
  $member NinthPos
  $member TenthPos
  $member EleventhPos
  $member TwelfthPos
  $member ThirteenthPos
  $member FourteenthPos
  $member FifteenthPos
  $member ThirdPos
  $member TilesPositions
  $member TilesMovement
  $member SixteenthPos
  $member GuessedText
  $member FirstTileMovement
  $member SecondTileMovement
  $member ThirdTileMovement
  $member FourthTileMovement
  $member FifthTileMovement
  $member SixthTileMovement
  $member SeventhTileMovement
  $member EighthTileMovement
  $member NinthTileMovement
  $member TenthTileMovement
  $member EleventhTileMovement
  $member TwelfthTileMovement
  $member ThirteenthTileMovement
  $member FourteenthTileMovement
  $member FifteenthTileMovement
  $member SixteenthTileMovement
  $member FindSolution
  $member Note
  $member GameLogic
  $member PositionsLegend2
  $member TilesMovement1
  $member TilesPositions1
  $member Effects
  $member RevealCompletedPicture
  $member RevealAllTiles
  $member RevealAnswer
  $member RevealTilesTimer
  $member RevealPictureTimer
  $member Solution
  $member RevealGuessedTextTimer
  $member RevealGuessedText
  $member FilterKeyboard
  $member GuessedTextPulse
  $member RevealFilterTimer
  $member RevealFilter
  $member FilterEffect
  $member DisableEffect
  $member DisableEffectTimer
  $member OpenMenu
  $member MenuButtonConfig
  $member MenuButton
  $member Guessed
  $member LostText
  $member LostGame
  $member LoseGameTimer
  $member TimeLeft
  $member UpdateTimerSlot
  $member UpdateTimer
  $member Time
  $member Variable
  $member VerifyActivePlayingTimer
  $member VerifyActivePlaying
  $member ActiveDialogBool
}

// Images tiles puzzle
note group ImagesTilesPuzzle
{
  attr Bounds = <1360,420,2060,810>;
}

$rect <1410,480,1610,520>
$output false
resource Resources::Bitmap Frame
{
  attr bitmapfile FileName = .\frame_rectangle_picture.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,530,1610,570>
$output false
resource Resources::Bitmap FirstTile
{
  attr bitmapfile FileName = .\first_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,580,1610,620>
$output false
resource Resources::Bitmap SecondTile
{
  attr bitmapfile FileName = .\second_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,630,1610,670>
$output false
resource Resources::Bitmap ThirthTile
{
  attr bitmapfile FileName = .\third_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,680,1610,720>
$output false
resource Resources::Bitmap ForthTile
{
  attr bitmapfile FileName = .\forth_tile.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1410,730,1610,770>
$output false
resource Resources::Bitmap FifthTile
{
  attr bitmapfile FileName = .\fifth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,480,2030,520>
$output false
resource Resources::Bitmap TwelfthTile
{
  attr bitmapfile FileName = .\twelfth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,480,1820,520>
$output false
resource Resources::Bitmap SixthTile
{
  attr bitmapfile FileName = .\sixth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,530,1820,570>
$output false
resource Resources::Bitmap SeventhTile
{
  attr bitmapfile FileName = .\seventh_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,580,1820,620>
$output false
resource Resources::Bitmap EighthTile
{
  attr bitmapfile FileName = .\eighth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,630,1820,670>
$output false
resource Resources::Bitmap NinthTile
{
  attr bitmapfile FileName = .\ninth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,680,1820,720>
$output false
resource Resources::Bitmap TenthTile
{
  attr bitmapfile FileName = .\tenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1620,730,1820,770>
$output false
resource Resources::Bitmap EleventhTile
{
  attr bitmapfile FileName = .\eleventh_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,530,2030,570>
$output false
resource Resources::Bitmap ThirteenTile
{
  attr bitmapfile FileName = .\thirteenth_tile.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,580,2030,620>
$output false
resource Resources::Bitmap ForteenthTile
{
  attr bitmapfile FileName = .\forteenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,630,2030,670>
$output false
resource Resources::Bitmap FifteenthTile
{
  attr bitmapfile FileName = .\fifteenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,680,2030,720>
$output false
resource Resources::Bitmap SixteenthTile
{
  attr bitmapfile FileName = .\sixteenth_tile1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1025,830,1225,870>
$output false
resource Resources::Bitmap Arrow
{
  attr bitmapfile FileName = .\arrow.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1830,730,2030,770>
$output false
resource Resources::Bitmap Medusa
{
  attr bitmapfile FileName = .\medusa1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Menus
note group Menus
{
  attr Bounds = <690,940,1030,1190>;
}

$rect <730,990,980,1030>
$output false
class Menu : Core::Group
{
  $rect <30,1250,230,1290>
  inherited property Bounds = <0,0,800,627>;

  $rect <30,1410,230,1450>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <30,1370,230,1410>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image Frame
  {
    preset StackingPriority = 8;
    preset Bounds = <138,141,631,628>;
    preset Bitmap = Application::MenuFrame;
  }

  $rect <20,20,160,60>
  object Views::FilterImage BlackFilter
  {
    preset StackingPriority = 9;
    preset Bounds = <299,265,474,478>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = Application::Black;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 140;
    preset Visible = true;
  }

  $rect <-370,100,-170,140>
  slot CloseMenu
  {
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::FilterImage BlackFilterBackground
  {
    preset StackingPriority = 7;
    preset Bounds = <2,-28,803,657>;
    preset Bitmap = Application::BackgroudGamingRoom;
    preset TintColor = Application::Black;
    preset TintIntensity = 5.0;
    preset TintMode = Graphics::TintMode.TintByOpacity;
    preset Opacity = 100;
    preset Visible = true;
  }

  $rect <-440,650,-320,690>
  inherited method Init()
  {
    ButtonsTimer.Enabled=true;

  }

  $rect <-290,589,-50,629>
  object WidgetSet::PushButtonConfig ButtonConfig
  {
    preset LabelColorActive = Application::VibrantOrange;
    preset LabelColorFocused = Application::Black;
    preset LabelColorDisabled = Application::Black;
    preset LabelColorDefault = Application::Black;
    preset IconTintActive = Application::VibrantOrange;
    preset IconTintFocused = Application::Black;
    preset IconTintDisabled = Application::Black;
    preset IconTintDefault = Application::Black;
    preset LabelFont = Application::WordGuessingGameSmallFont;
  }

  $rect <-510,280,-300,320>
  object Core::Timer ButtonsTimer
  {
    preset OnTrigger = ShowButtons;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-250,280,-60,320>
  slot ShowButtons
  {
    FilterEffect.Enabled=true;
     
                    
    //Game.Visible=true; 
    //ExtraTime.Enabled=true;
    Rules.Visible=true;

    SecondPulseColorTimer.Enabled=true;


  }

  $rect <-510,330,-300,370>
  object Core::Timer SecondPulseColorTimer
  {
    preset OnTrigger = SecondPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-250,530,-60,570>
  slot StopPulseColor
  {
    FilterEffect.Outlet=null;
  }

  $rect <-250,383,-60,423>
  slot ThirdPulseColor
  {
     Game.Visible=true;
    ForthPulseColorTimer.Enabled=true;
  }

  $rect <-510,530,-300,570>
  object Core::Timer StopPulseColorTimer
  {
    preset OnTrigger = StopPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-530,590,-330,630>
  object Effects::ColorEffect FilterEffect
  {
    preset OnAnimate = null;
    preset Bounces = 5;
    preset Oscillations = 1;
    preset Timing = Effects::Timing.Circle_Out;
    preset Value2 = #000000FF;
    preset Value1 = Application::VibrantOrange;
    preset Outlet = ^BlackFilter.TintColor;
  }

  $rect <-510,385,-300,425>
  object Core::Timer ThirdPulseColorTimer
  {
    preset OnTrigger = ThirdPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-250,330,-60,370>
  slot SecondPulseColor
  {
    //GameRoom.Visible=true;
    Music.Visible=true;
     
    ThirdPulseColorTimer.Enabled=true;
  }

  $rect <-370,50,-170,90>
  slot BackToGameSlot
  {
    //if ( IsDialog(false))
      //{
     // Owner.DismissDialog( this, null, null, null, null, null, false ); 
      //Owner.DismissDialog( Application::Menu, null, null, null, null, null, false );


    //  Owner.DismissDialog( this, null, null, null, null, null, false );
            var slot sl=this.CloseMenu;
          signal sl;    
        Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );


  }

  $rect <-370,150,-170,190>
  slot BackToGameRoom
  {


     Owner.DismissDialog( this.FindCurrentDialog(), null, null, null, null, null, false ); 
    //  Owner.DismissDialog( Application::Menu, null, null, null, null, null, false );
    //  }
    //GetRoot().DismissDialog( this, null, null, null, null, null, false );
    GetRoot().SwitchToDialog(new Application::GameRoom, null, null, null, null, null, null, null, null, null, false );
     //trace this.FindCurrentDialog();

  }

  $rect <-310,650,-170,690>
  slot MusicSLot
  {
    $if (!$prototyper)
    native{isAudioPlaying();}
    $endif 
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Game
  {
    preset StackingPriority = 8;
    preset Bounds = <310,379,452,411>;
    preset Visible = false;
    preset OnPress = BackToGameSlot;
    preset Label = "Back to the game";
    preset Appearance = ButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton GameRoom
  {
    preset StackingPriority = 9;
    preset Bounds = <309,411,451,465>;
    preset Visible = false;
    preset OnPress = BackToGameRoom;
    preset Label = "Back to the game room";
    preset Appearance = ButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Music
  {
    preset StackingPriority = 9;
    preset Bounds = <310,323,452,361>;
    preset Visible = false;
    preset OnPress = MusicSLot;
    preset Label = "Play/Pause Music";
    preset Appearance = ButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Rules
  {
    preset StackingPriority = 9;
    preset Bounds = <341,291,423,330>;
    preset Visible = false;
    preset OnPress = BackToGameRoom;
    preset Label = "Rules";
    preset Appearance = ButtonConfig;
  }

  $rect <-510,430,-300,470>
  object Core::Timer ForthPulseColorTimer
  {
    preset OnTrigger = ForthPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-260,431,-60,471>
  slot ForthPulseColor
  {
    GameRoom.Visible=true;

    FifthPulseColorTimer.Enabled=true;
  }

  // Functionality buttons
  note group FunctionalityButtonsNote
  {
    attr Bounds = <-420,0,-120,220>;
  }

  // Effetcs
  note group EffetcsNote
  {
    attr Bounds = <-540,240,-30,700>;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Restart
  {
    preset StackingPriority = 9;
    preset Bounds = <339,353,421,392>;
    preset Visible = true;
    preset OnPress = BackToGameRoom;
    preset Label = "Restart";
    preset Appearance = ButtonConfig;
  }

  $rect <-510,480,-300,520>
  object Core::Timer FifthPulseColorTimer
  {
    preset OnTrigger = FifthPulseColor;
    preset Period = 0;
    preset Begin = 1000;
  }

  $rect <-260,480,-60,520>
  slot FifthPulseColor
  {
    Restart.Visible=true;

    StopPulseColorTimer.Enabled=true;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Frame
  $member BlackFilter
  $member CloseMenu
  $member BlackFilterBackground
  $member ButtonConfig
  $member ButtonsTimer
  $member ShowButtons
  $member SecondPulseColorTimer
  $member StopPulseColor
  $member ThirdPulseColor
  $member StopPulseColorTimer
  $member FilterEffect
  $member ThirdPulseColorTimer
  $member SecondPulseColor
  $member BackToGameSlot
  $member BackToGameRoom
  $member MusicSLot
  $member Game
  $member GameRoom
  $member Music
  $member Rules
  $member ForthPulseColorTimer
  $member ForthPulseColor
  $member FunctionalityButtonsNote
  $member EffetcsNote
  $member Restart
  $member FifthPulseColorTimer
  $member FifthPulseColor
}

$rect <750,1040,980,1080>
$output false
class GuessTheWordMenu : Application::Menu
{
  $rect <-10,2420,190,2460>
  inherited property Bounds = <0,0,800,486>;

  $rect <-10,2580,190,2620>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-10,2540,190,2580>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-260,120,-80,160>
  inherited method Init()
  {
    Rules.OnPress=OpenRulePage;
    Restart.OnPress=OpenGuessingGame;

  }

  $rect <20,20,160,60>
  inherited object Frame
  {
    preset Bounds = <154,-1,647,486>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilter
  {
    preset Bounds = <311,136,486,349>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilterBackground
  {
    preset Bounds = <-2,-1,799,486>;
  }

  $rect <-800,40,-600,80>
  var int32 Variable = 0;

  $rect <20,20,160,60>
  inherited object Game
  {
    preset StackingPriority = 12;
    preset Bounds = <327,214,469,246>;
  }

  $rect <20,20,160,60>
  inherited object GameRoom
  {
    preset StackingPriority = 11;
    preset Bounds = <328,246,470,300>;
  }

  $rect <20,20,160,60>
  inherited object Music
  {
    preset Bounds = <327,176,469,214>;
  }

  $rect <20,20,160,60>
  inherited object Rules
  {
    preset Bounds = <353,151,435,179>;
  }

  $rect <-280,170,-80,210>
  slot OpenRulePage
  {
    GetRoot().PresentDialog( new Application::GuessingGameRules,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  $rect <20,20,160,60>
  inherited object Restart
  {
    preset Bounds = <358,299,440,327>;
    preset Visible = false;
    preset OnPress = OpenGuessingGame;
  }

  $rect <-280,220,-80,260>
  slot OpenGuessingGame
  {
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );

    Owner.DismissDialog( this.FindDialogByClass( Application::GuessTheWord), null, null, null, null, null, false );

    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );



  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Game
  $member GameRoom
  $member Frame
  $member BlackFilter
  $member Music
  $member BlackFilterBackground
  $member Variable
  $member Rules
  $member Restart
  $member OpenRulePage
  $member OpenGuessingGame

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder BackToGameSlot 18
  $reorder Game 20
  $reorder GameRoom 20
  $reorder BackToGameRoom 18
  $reorder Music 12
  $reorder MusicSLot 11
  $reorder Variable 12
}

$rect <1950,100,2150,140>
$output false
resource Resources::Bitmap MenuFrame
{
  attr bitmapfile FileName = .\menu_frame.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1950,150,2150,190>
$output false
resource Resources::Bitmap MenuBackground
{
  attr bitmapfile FileName = .\menu_background.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <720,1250,930,1290>
$output false
const color DarkOrange = #C67528FF;

// Colors
note group Colors
{
  attr Bounds = <690,1210,1400,1360>;
}

$rect <720,1300,930,1340>
$output false
const color VibrantOrange = #F3A52BFF;

$rect <950,1300,1160,1340>
$output false
const color LightOrange = #FFD10DFF;

$rect <950,1250,1160,1290>
$output false
const color Black = #000000FF;

$rect <1950,200,2150,240>
$output false
resource Resources::Bitmap open_menu
{
  attr bitmapfile FileName = .\open_icon.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// Menu images
note group MenuImages
{
  attr Bounds = <1900,50,2200,330>;
}

$rect <1950,250,2150,290>
$output false
resource Resources::Bitmap close_icon
{
  attr bitmapfile FileName = .\close_icon.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <1420,1130,1660,1170>
$output false
resource Resources::Font WordGuessingGameSmallFont
{
  attr fontname FontName = Constantia;
  attr fontheight Height = 17;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <1170,1250,1380,1290>
$output false
const color SandColor = #CCC0AFFF;

$rect <1770,1090,1970,1130>
$output false
class GameRoom : Core::Group
{
  $rect <-970,20,-770,60>
  inherited property Bounds = <0,0,800,480>;

  $rect <-970,180,-770,220>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-970,140,-770,180>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-590,300,-410,340>
  inherited method Init()
  {
  }

  $rect <-610,405,-370,445>
  object WidgetSet::PushButtonConfig TransparentButton;

  $rect <-290,65,-60,105>
  slot OpenGuessingWordGame
  {
    //if ( IsDialog(false))
     //Owner.DismissDialog( this, null, null, null, null, null, false );
    //                     trace "Actual dialog1g", Owner;
    if ( IsActiveDialog( true ))
    {

      //GetRoot().PresentDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
      GetRoot().SwitchToDialog( new Application::GuessTheWord,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //      trace "Actual dialog2g", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;

  }

  // Starting games
  note group StartingGames
  {
    attr Bounds = <-330,15,-30,225>;
  }

  // Effects handling
  note group Effects
  {
    attr Bounds = <-330,255,-30,455>;
  }

  // Timers for the effects
  note group Timers
  {
    attr Bounds = <-650,15,-350,215>;
  }

  $rect <-600,55,-400,95>
  object Core::Timer TimerGuessingGame
  {
    preset OnTrigger = OpenGuessingWordGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-300,305,-50,345>
  slot OnPressGuessingWordGame
  {
    WordGuessingButton.Icon=Application::OnPressWordGuessingLogo;


    TimerGuessingGame.Enabled=true;


  }

  $rect <-290,115,-60,155>
  slot OpenMemoryGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //  trace "Actual dialog1m", Owner;

    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::MemoryGame,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, null, false );
    //                       trace "Actual dialog2m", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,355,-50,395>
  slot OnPressMemoryGame
  {
    MemoryGameButton.Icon=Application::OnPressMemoryGameLogo;


    TimerMemoryGame.Enabled=true;


  }

  $rect <-600,105,-400,145>
  object Core::Timer TimerMemoryGame
  {
    preset OnTrigger = OpenMemoryGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-600,235,-400,275>
  slot DisableButtons
  {
    WordGuessingButton.Enabled=false;
    WordGuessingButton.Visible=false;
    MemoryGameButton.Enabled=false;
    MemoryGameButton.Visible=false;
    TilesPuzzleGameButton.Enabled=false;
    TilesPuzzleGameButton.Visible=false;
    Arrow.Enabled=false;
    Arrow.Visible=false;
    Sound.Enabled=false;
    Sound.Visible=false;

  }

  $rect <-600,155,-400,195>
  object Core::Timer TimeTilesPuzzleGame
  {
    preset OnTrigger = OpenTilesPuzzleGame;
    preset Period = 0;
    preset Begin = 1300;
  }

  $rect <-290,165,-60,205>
  slot OpenTilesPuzzleGame
  {
    //if ( IsDialog(false))
     // Owner.DismissDialog( this, null, null, null, null, null, false );
    //      trace "Actual dialog1t", Owner;
    if ( IsActiveDialog( true ))
    {

    //  GetRoot().PresentDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null, false );
      //    GetRoot().PresentDialog( new Application::GuessTheWord,null, null, null, null, null, null, null, null, false );
       GetRoot().SwitchToDialog( new Application::TilesPuzzle,Effects::SlideLeftCentered, Effects::FadeInOutCentered, null, null, null, null, null, null,null, false );
    //  trace "Actual dialog2t", Owner;
    }

    var slot sl=this.DisableButtons;
    signal sl;


  }

  $rect <-300,405,-50,445>
  slot OnPressTilesPuzzleGame
  {
    TilesPuzzleGameButton.Icon=Application::OnPressTilesPuzzleLogo;


    TimeTilesPuzzleGame.Enabled=true;


  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Application::BackgroudGamingRoom;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton WordGuessingButton
  {
    preset Bounds = <157,172,289,305>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressGuessingWordGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::WordGuessingLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MemoryGameButton
  {
    preset Bounds = <324,169,456,302>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressMemoryGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::MemoryGameLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TilesPuzzleGameButton
  {
    preset Bounds = <486,169,633,302>;
    preset OnLeave = null;
    preset OnEnter = null;
    preset OnRelease = null;
    preset OnPress = OnPressTilesPuzzleGame;
    preset OnActivate = null;
    preset IconFrameActive = 2;
    preset IconFrameFocused = -1;
    preset IconFrameDisabled = -1;
    preset IconFrameDefault = -1;
    preset Icon = Application::TilesPuzzleLogo;
    preset Label = "";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Arrow
  {
    preset Bounds = <636,523,730,574>;
    preset Icon = Application::Arrow;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Sound
  {
    preset Bounds = <46,47,120,115>;
    preset OnPress = MusicSLot;
    preset Icon = Application::sound_on;
    preset Label = "Caption";
    preset Appearance = TransparentButton;
  }

  $rect <-280,480,-80,520>
  slot MusicSLot
  {
    $if (!$prototyper)
    native{isAudioPlaying();}
    $endif 
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member TransparentButton
  $member OpenGuessingWordGame
  $member StartingGames
  $member Effects
  $member Timers
  $member TimerGuessingGame
  $member OnPressGuessingWordGame
  $member OpenMemoryGame
  $member OnPressMemoryGame
  $member TimerMemoryGame
  $member DisableButtons
  $member TimeTilesPuzzleGame
  $member OpenTilesPuzzleGame
  $member OnPressTilesPuzzleGame
  $member Image
  $member WordGuessingButton
  $member MemoryGameButton
  $member TilesPuzzleGameButton
  $member Arrow
  $member Sound
  $member MusicSLot
}

$rect <1240,830,1440,870>
$output false
resource Resources::Bitmap sound_on
{
  attr bitmapfile FileName = .\sound_on.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1460,830,1660,870>
$output false
resource Resources::Bitmap sound_off
{
  attr bitmapfile FileName = .\sound_off.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Digits
note group DigitsNote
{
  attr Bounds = <2080,380,2270,850>;
}

$rect <2120,430,2220,470>
$output false
resource Resources::Bitmap Digit0
{
  attr bitmapfile FileName = .\0.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,470,2220,510>
$output false
resource Resources::Bitmap Digit1
{
  attr bitmapfile FileName = .\1.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,510,2220,550>
$output false
resource Resources::Bitmap Digit2
{
  attr bitmapfile FileName = .\2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,550,2220,590>
$output false
resource Resources::Bitmap Digit3
{
  attr bitmapfile FileName = .\3.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,590,2220,630>
$output false
resource Resources::Bitmap Digit4
{
  attr bitmapfile FileName = .\4.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,630,2220,670>
$output false
resource Resources::Bitmap Digit5
{
  attr bitmapfile FileName = .\5.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,670,2220,710>
$output false
resource Resources::Bitmap Digit6
{
  attr bitmapfile FileName = .\6.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,710,2220,750>
$output false
resource Resources::Bitmap Digit7
{
  attr bitmapfile FileName = .\7.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,750,2220,790>
$output false
resource Resources::Bitmap Digit8
{
  attr bitmapfile FileName = .\8.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <2120,790,2220,830>
$output false
resource Resources::Bitmap Digit9
{
  attr bitmapfile FileName = .\9.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Rules
note group RulesNote
{
  attr Bounds = <1050,940,1370,1190>;
}

$rect <1080,990,1330,1030>
$output false
class Rules : Core::Group
{
  $rect <10,720,210,760>
  inherited property Bounds = <0,0,800,480>;

  $rect <10,880,210,920>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,840,210,880>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image r
  {
    preset StackingPriority = 1;
    preset Bounds = <267,37,317,87>;
    preset Bitmap = Application::r;
  }

  $rect <20,20,160,60>
  object Views::Image u
  {
    preset StackingPriority = 1;
    preset Bounds = <319,40,369,90>;
    preset Bitmap = Application::u;
  }

  $rect <20,20,160,60>
  object Views::Image l
  {
    preset StackingPriority = 1;
    preset Bounds = <366,40,416,90>;
    preset Bitmap = Application::l;
  }

  $rect <20,20,160,60>
  object Views::Image e
  {
    preset StackingPriority = 1;
    preset Bounds = <416,42,466,92>;
    preset Bitmap = Application::e;
  }

  $rect <20,20,160,60>
  object Views::Image s
  {
    preset StackingPriority = 1;
    preset Bounds = <466,42,516,92>;
    preset Bitmap = Application::s;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Button
  {
    preset StackingPriority = 2;
    preset Bounds = <324,360,459,466>;
    preset OnPress = null;
    preset Icon = Application::Button;
    preset Label = "Exit";
    preset Appearance = PushButtonConfig;
  }

  $rect <270,500,510,540>
  object WidgetSet::PushButtonConfig PushButtonConfig;

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Application::BackgroudGamingRoom;
  }
}

$rect <1100,1040,1330,1080>
$output false
class GuessingGameRules : Application::Rules
{
  $rect <-360,340,-160,380>
  inherited property Bounds = <0,0,800,480>;

  $rect <-360,500,-160,540>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-360,460,-160,500>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object r
  {
    preset Bounds = <271,32,321,82>;
  }

  $rect <20,20,160,60>
  inherited object u
  {
    preset Bounds = <323,35,373,85>;
  }

  $rect <20,20,160,60>
  inherited object l
  {
    preset Bounds = <370,35,420,85>;
  }

  $rect <20,20,160,60>
  inherited object e
  {
    preset StackingPriority = 3;
    preset Bounds = <420,40,470,90>;
  }

  $rect <20,20,160,60>
  inherited object s
  {
    preset Bounds = <470,37,520,87>;
  }

  $rect <20,20,160,60>
  object Views::Text FirstRule
  {
    preset StackingPriority = 1;
    preset Bounds = <245,93,538,197>;
    preset ColorTR = #FFE734FF;
    preset ColorTL = #FFFFFFFF;
    preset String = "You start by guessing any four letters. ";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondRulePartOne
  {
    preset StackingPriority = 1;
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <2,145,786,234>;
    preset Orientation = Views::Orientation.Normal;
    preset ColorTR = #FFE734FF;
    preset String = "If you guess any of the word`s letters and their positions, ";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text ThirdRule
  {
    preset StackingPriority = 1;
    preset Bounds = <70,250,747,278>;
    preset ColorTR = #FFE734FF;
    preset String = "If you guess a letter, but not its placement it will appear at the bottom of the screen. ";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text ForthRule
  {
    preset StackingPriority = 1;
    preset Bounds = <129,286,672,330>;
    preset ColorTR = #FFE734FF;
    preset String = "You have a limited number of tries to guess the word before you lose.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondRulePartTwo
  {
    preset StackingPriority = 1;
    preset Bounds = <172,205,629,235>;
    preset ColorTR = #FFE734FF;
    preset String = "you will see the letter or letters revealed in black.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <-350,110,-170,150>
  inherited method Init()
  {
    Button.OnPress=BackToMenuSlot;
  }

  $rect <20,20,160,60>
  inherited object Button
  {
    preset StackingPriority = 2;
  }

  $rect <20,20,160,60>
  object Views::Text BackToMenu
  {
    preset StackingPriority = 1;
    preset Bounds = <163,330,620,360>;
    preset ColorTR = #FFE734FF;
    preset String = "The button bellow will bring you back to the menu";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <-360,210,-160,250>
  slot BackToMenuSlot
  {
    Button.Visible=false;
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member r
  $member u
  $member l
  $member e
  $member s
  $member Button
  $member FirstRule
  $member SecondRulePartOne
  $member ThirdRule
  $member ForthRule
  $member SecondRulePartTwo
  $member BackToMenu
  $member BackToMenuSlot
}

$rect <1680,830,1880,870>
$output false
resource Resources::Bitmap Button
{
  attr bitmapfile FileName = .\button.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <750,1090,980,1130>
$output false
class MemoryGameMenu : Application::Menu
{
  $rect <-10,2420,190,2460>
  inherited property Bounds = <0,0,800,486>;

  $rect <-10,2580,190,2620>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-10,2540,190,2580>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-260,120,-80,160>
  inherited method Init()
  {
    Rules.OnPress=OpenRulePage;
    Restart.OnPress=OpenMemoryGame;

  }

  $rect <20,20,160,60>
  inherited object Frame
  {
    preset Bounds = <154,-1,647,486>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilter
  {
    preset Bounds = <311,136,486,349>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilterBackground
  {
    preset Bounds = <-2,-1,799,486>;
  }

  $rect <20,20,160,60>
  inherited object Game
  {
    preset StackingPriority = 12;
    preset Bounds = <327,229,469,261>;
  }

  $rect <20,20,160,60>
  inherited object GameRoom
  {
    preset StackingPriority = 11;
    preset Bounds = <328,261,470,315>;
  }

  $rect <20,20,160,60>
  inherited object Music
  {
    preset Bounds = <327,191,469,229>;
  }

  $rect <20,20,160,60>
  inherited object Rules
  {
    preset Bounds = <353,157,435,196>;
  }

  $rect <-280,170,-80,210>
  slot OpenRulePage
  {
    GetRoot().PresentDialog( new Application::MemoryGameRules,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  $rect <20,20,160,60>
  inherited object Restart
  {
    preset Bounds = <353,302,435,341>;
    preset Visible = false;
  }

  $rect <-280,220,-80,260>
  slot OpenMemoryGame
  {
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );

    Owner.DismissDialog( this.FindDialogByClass( Application::MemoryGame), null, null, null, null, null, false );

    GetRoot().PresentDialog( new Application::MemoryGame,null, null, null, null, null, null, null, null, false );



  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Game
  $member GameRoom
  $member Frame
  $member BlackFilter
  $member Music
  $member BlackFilterBackground
  $member Rules
  $member Restart
  $member OpenRulePage
  $member OpenMemoryGame

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder BackToGameSlot 18
  $reorder Game 20
  $reorder GameRoom 20
  $reorder BackToGameRoom 18
  $reorder Music 12
  $reorder MusicSLot 11
}

$rect <1100,1090,1330,1130>
$output false
class MemoryGameRules : Application::Rules
{
  $rect <-360,340,-160,380>
  inherited property Bounds = <0,0,800,480>;

  $rect <-360,500,-160,540>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-360,460,-160,500>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object r
  {
    preset Bounds = <271,32,321,82>;
  }

  $rect <20,20,160,60>
  inherited object u
  {
    preset Bounds = <323,35,373,85>;
  }

  $rect <20,20,160,60>
  inherited object l
  {
    preset Bounds = <370,35,420,85>;
  }

  $rect <20,20,160,60>
  inherited object e
  {
    preset StackingPriority = 3;
    preset Bounds = <420,40,470,90>;
  }

  $rect <20,20,160,60>
  inherited object s
  {
    preset Bounds = <470,37,520,87>;
  }

  $rect <20,20,160,60>
  object Views::Text FirstRule
  {
    preset StackingPriority = 1;
    preset Bounds = <180,149,611,186>;
    preset ColorTR = #FFE734FF;
    preset ColorTL = #FFFFFFFF;
    preset String = "The goal is to find all the matching pairs of cards.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondRulePartOne
  {
    preset StackingPriority = 1;
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <-1,205,783,248>;
    preset Orientation = Views::Orientation.Normal;
    preset ColorTR = #FFE734FF;
    preset String = "If you find two matching cards, they will remain visible. ";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text ForthRule
  {
    preset StackingPriority = 1;
    preset Bounds = <129,257,672,301>;
    preset ColorTR = #FFE734FF;
    preset String = "To win, you have to find all the matching cards within one minute.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <-350,110,-170,150>
  inherited method Init()
  {
    Button.OnPress=BackToMenuSlot;
  }

  $rect <20,20,160,60>
  inherited object Button
  {
    preset StackingPriority = 2;
  }

  $rect <20,20,160,60>
  object Views::Text BackToMenu
  {
    preset StackingPriority = 1;
    preset Bounds = <163,315,620,345>;
    preset ColorTR = #FFE734FF;
    preset String = "The button bellow will bring you back to the menu";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <-360,210,-160,250>
  slot BackToMenuSlot
  {
    Button.Visible=false;
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member r
  $member u
  $member l
  $member e
  $member s
  $member Button
  $member FirstRule
  $member SecondRulePartOne
  $member ForthRule
  $member BackToMenu
  $member BackToMenuSlot
}

$rect <750,1140,980,1180>
$output false
class TilesPuzzleMenu : Application::Menu
{
  $rect <-10,2420,190,2460>
  inherited property Bounds = <0,0,800,486>;

  $rect <-10,2580,190,2620>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-10,2540,190,2580>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <-260,120,-80,160>
  inherited method Init()
  {
    Rules.OnPress=OpenRulePage;
    Restart.OnPress=OpenTilePuzzleGame;

  }

  $rect <20,20,160,60>
  inherited object Frame
  {
    preset Bounds = <154,-1,647,486>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilter
  {
    preset Bounds = <311,136,486,349>;
  }

  $rect <20,20,160,60>
  inherited object BlackFilterBackground
  {
    preset Bounds = <-2,-1,799,486>;
  }

  $rect <-800,40,-600,80>
  var int32 Variable = 0;

  $rect <20,20,160,60>
  inherited object Game
  {
    preset StackingPriority = 12;
    preset Bounds = <327,229,469,261>;
  }

  $rect <20,20,160,60>
  inherited object GameRoom
  {
    preset StackingPriority = 11;
    preset Bounds = <328,261,470,315>;
  }

  $rect <20,20,160,60>
  inherited object Music
  {
    preset Bounds = <327,191,469,229>;
  }

  $rect <20,20,160,60>
  inherited object Rules
  {
    preset Bounds = <353,157,435,196>;
  }

  $rect <-280,170,-80,210>
  slot OpenRulePage
  {
    GetRoot().PresentDialog( new Application::TilesPuzzleRules,Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  $rect <20,20,160,60>
  inherited object Restart
  {
    preset Bounds = <357,310,439,349>;
    preset Visible = false;
  }

  $rect <-280,220,-80,260>
  slot OpenTilePuzzleGame
  {
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );

    Owner.DismissDialog( this.FindDialogByClass( Application::TilesPuzzle), null, null, null, null, null, false );

    GetRoot().PresentDialog( new Application::TilesPuzzle,null, null, null, null, null, null, null, null, false );



  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Game
  $member GameRoom
  $member Frame
  $member BlackFilter
  $member Music
  $member BlackFilterBackground
  $member Variable
  $member Rules
  $member Restart
  $member OpenRulePage
  $member OpenTilePuzzleGame

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder BackToGameSlot 18
  $reorder Game 20
  $reorder GameRoom 20
  $reorder BackToGameRoom 18
  $reorder Music 12
  $reorder MusicSLot 11
  $reorder Variable 12
}

$rect <1100,1140,1330,1180>
$output false
class TilesPuzzleRules : Application::Rules
{
  $rect <-360,340,-160,380>
  inherited property Bounds = <0,0,800,480>;

  $rect <-360,500,-160,540>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-360,460,-160,500>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  inherited object r
  {
    preset Bounds = <271,22,321,72>;
  }

  $rect <20,20,160,60>
  inherited object u
  {
    preset Bounds = <323,25,373,75>;
  }

  $rect <20,20,160,60>
  inherited object l
  {
    preset Bounds = <370,25,420,75>;
  }

  $rect <20,20,160,60>
  inherited object e
  {
    preset StackingPriority = 3;
    preset Bounds = <420,30,470,80>;
  }

  $rect <20,20,160,60>
  inherited object s
  {
    preset Bounds = <470,27,520,77>;
  }

  $rect <20,20,160,60>
  object Views::Text FirstRule
  {
    preset StackingPriority = 1;
    preset Bounds = <162,79,628,131>;
    preset ColorTR = #FFE734FF;
    preset ColorTL = #FFFFFFFF;
    preset String = "The goal is to rearrange the tiles to form a completed picture.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondRuleParOne
  {
    preset StackingPriority = 1;
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <-1,134,783,178>;
    preset Orientation = Views::Orientation.Normal;
    preset ColorTR = #FFE734FF;
    preset String = "empty to allow movement. ";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text ForthRule
  {
    preset StackingPriority = 1;
    preset Bounds = <63,199,740,227>;
    preset ColorTR = #FFE734FF;
    preset String = "Tiles slide horizontally or vertically into the empty space; diagonal moves are not allowed.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text FifthRulePartOne
  {
    preset StackingPriority = 1;
    preset Bounds = <0,227,798,271>;
    preset ColorTR = #FFE734FF;
    preset String = "To win, you must arrange the tiles in the correct sequence or complete the picture  ";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text ThirdRule
  {
    preset StackingPriority = 1;
    preset Bounds = <167,167,624,197>;
    preset ColorTR = #FFE734FF;
    preset String = "You can only move tiles that are adjacent to the empty space.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <-350,110,-170,150>
  inherited method Init()
  {
    Button.OnPress=BackToMenuSlot;
  }

  $rect <20,20,160,60>
  inherited object Button
  {
    preset StackingPriority = 2;
  }

  $rect <20,20,160,60>
  object Views::Text BackToMenu
  {
    preset StackingPriority = 1;
    preset Bounds = <172,330,629,360>;
    preset ColorTR = #FFE734FF;
    preset String = "The button bellow will bring you back to the menu";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <-360,210,-160,250>
  slot BackToMenuSlot
  {
    Button.Visible=false;
    Owner.DismissDialog( FindCurrentDialog(), null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Text SixthRule
  {
    preset StackingPriority = 1;
    preset Bounds = <9,286,807,330>;
    preset ColorTR = #FFE734FF;
    preset String = "You have one minute to solve the puzzle.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text FifthRulePartOne1
  {
    preset StackingPriority = 1;
    preset Bounds = <2,257,800,287>;
    preset ColorTR = #FFE734FF;
    preset String = "in the correct sequence or complete the picture with the empty space in its designated spot.";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondRulePartTwo
  {
    preset StackingPriority = 1;
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <-1,112,783,156>;
    preset Orientation = Views::Orientation.Normal;
    preset ColorTR = #FFE734FF;
    preset String = "The puzzle begins with the tiles in a random configuration, with one tile space ";
    preset Font = Application::WordGuessingGameSmallFont;
    preset Color = #8A7429FF;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member r
  $member u
  $member l
  $member e
  $member s
  $member Button
  $member FirstRule
  $member SecondRuleParOne
  $member ForthRule
  $member FifthRulePartOne
  $member ThirdRule
  $member BackToMenu
  $member BackToMenuSlot
  $member SixthRule
  $member FifthRulePartOne1
  $member SecondRulePartTwo
}
